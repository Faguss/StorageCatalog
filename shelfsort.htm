<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta http-equiv="x-ua-compatible" content="ie=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Lokalizowanie akt</title>
	<style>
	table {
  		border-collapse: collapse;
		margin-top: 1em;
	}
	table caption {
		font-size: x-small;
  		text-align: right;
  		margin-bottom: 4px;
		display: none;
	}
	th {
		text-align: center;
		background-color: #afb3b1;
		border: 1px solid #ddd;
		padding: 8px;
	}
	tbody td {
		border: 1px solid #ddd;
		padding-left: 8px;
		padding-right: 8px;
		font-size: small;
	}
	tbody tr:nth-child(even) {
		background-color: #e4e4e4;
	}
	tbody tr:hover {
		background-color: #66e66d;
	}
	tfoot {
		text-align: right;
		font-style: italic; 
		font-size: small;
	}
	#draganddrop_field {
		position: fixed; 
		top: 0; 
		left: 0; 
		z-index: 9999999999;
		width: 100%;
		height: 100%;
		background-color: rgba(0,0,0,0.5);
		transition: visibility 175ms, opacity 175ms;
		display: flex;
		justify-content: center;
		align-items: center;
	}
	.draganddrop_field_text {
		font-family: sans-serif;
		font-size: 400%;
		text-transform: uppercase;
		font-weight: bold;
		color: rgb(182, 43, 43);
	}
	@keyframes orange-fade {
		from {
			background: #f96;
		}
		to {
			background: #ffffff00;
		}
	}
	.color_flash {
		background-color: orange;
	}
	#last_result {
		font-size: small;
		margin-top: 0;
		margin-bottom: 2px;
	}
	#last_result .highlight {
		color: #8b00ff;
	}
	.key_info {
		font-family: monospace;
		line-height:1.3em;
	}
	</style>
</head>

<body>
	<div style="margin-bottom:1em;" id="controls">
		<div style="visibility:hidden; opacity:0;" id="draganddrop_field" ondrop="drop_handler(event, this);" ondragover="event.preventDefault()" ondragleave="event.preventDefault()">
			<div class="draganddrop_field_text">Upuść tutaj pliki CSV/TXT</div>
		</div>

		<h1 style="text-align:center; font-family:sans-serif; text-transform: uppercase;">Lokalizowanie akt</h1>
		<p>Wpisz numery w polu poniżej lub przeciągnij plik z listą.</p>
		<textarea id="input" rows=10></textarea>
		<p id="last_result"></p>

		<input type="checkbox" id="continuesearch" name="continuesearch"><label for="continuesearch">Pokaż wyniki w krzyżujących się zakresach</label>
		<br>
		<button type="button" onclick="(function(style) {style.display=style.display==='none' ? '' : 'none';})(document.getElementById('tags_info').style);">Pokaż oznaczenia</button>
		<button type="button" onclick="(function(style) {style.display=style.display==='none' ? '' : 'none';})(document.getElementById('key_info').style);document.getElementById('key_info_select').dispatchEvent(new Event('change'))">Pokaż indeks</button>
		<button type="button" onclick="generate_csv(sort_numbers_to_shelves(document.getElementById('input').value, storage, document.getElementById('continuesearch').checked))">Utwórz plik CSV</button>
		<button type="button" onclick="print_html_table()">Wydrukuj</button>

		<div style="display:none;" id="tags_info">
			<p style="margin-bottom:0">Po numerze dopisz oznaczenie aby określić miejsce wyszukiwania. Na przykład: 
				<span style="font-family:monospace;" id="tags_example"></span>
				<br>
				Dostępne oznaczenia to:
			</p>
			<div style="font-size:small; margin-left:1em;" id="tags_list"></div>
			<p>Oznaczenia niezaczynające się od litery lub cyfry są ignorowane (służą jako komentarz).</p>
		</div>

		<div style="display:none;" id="key_info">
			<div style="margin-top:1em">
				<label for="key_info_select">Indeks sekcji:</label>
				<select name="key_info_select" id="key_info_select"></select>

				<label for="key_info_select_tag">Oznaczenie:</label>
				<select name="key_info_select_tag" id="key_info_select_tag">
					<option value="" selected="selected">brak</option>
				</select>

				<label for="key_info_select_sort">Sortuj wg:</label>
				<select name="key_info_select_sort" id="key_info_select_sort">
					<option value="default" selected="selected">kolejności wpisania</option>
					<option value="shelf">numeracji półek</option>
					<option value="suffix">końcówki</option>
				</select>
			</div>
			
			<div class="key_info" id="key_info_display"></div>
			
			<div id="key_info_map">
				<h3>Mapa szafy:</h3>
				<label for="key_info_map_display_sort">Sortuj wg:</label>
				<select name="key_info_map_display_sort" id="key_info_map_display_sort">
					<option value="place">miejsca</option>
					<option value="shelf">numeracji półek</option>
				</select>
				<input type="checkbox" id="key_info_map_toggle_content" name="key_info_map_toggle_content"><label for="key_info_map_toggle_content">Pokaż zawartość</label>
				<div style="margin-top:1em;" id="key_info_map_display"></div>
			</div>
		</div>
	</div>
	<div id="output"></div>

	<script>
	const DEFAULT_PREFIX = 'bi';
	const INPUT_ID_MAX_LEN = 8;
	const INPUT_ID_MAX_DIGITS = 5;
	const INPUT_ID_PREFIX_MAX_LEN = 3;
	const INPUT_ID_SUFFIX_MAX_LEN = 2;
	const CSV_IMPORT_DATA_FROM_COLUMN = 'Nr';
	const OUTPUT_TABLE_ID = 'output_table';
	const NON_MATCHING_SECTION_KEY = 'non_matching';

	const STORAGE_SECTION_NAMES = {
		'a': 'Szafa #1',
		'b': 'Szafa #2',
		'c': 'Szafa #3',
		'p': 'Piwnica',
		[NON_MATCHING_SECTION_KEY]: 'Nieznalezione',
	};

	const RAW_STORAGE_KEY = `
	A17 - AA 30915 - AA 38199 
	A19 - AA 38200 - AA 43899 
	A20 - AA 43900 - AA 49799 
	A21 - AA 49800 - AA 55399 
	A23 - AA 55400 - AA 60899 
	A24 - AA 60900 - AA 66099 
	A25 - AA 66100 - AA 71099 
	A26 - AA 71100 - AA 75799 
	A30 - AA 75800 - AA 81299 
	A32 - AA 81300 - AA 86399 
	A35 - AA 86400 - AA 91299 
	A36 - AA 91300 - AA 95999 
	A37 - AA 96000 - AA 99998 

	A40: AA 0002R - AA 3099R 
	A29: AA 3100R - AA 6599R 
	A22: AA 6600R - AA 9999R 
	A43: AA 0003C - AA 4299C 
	A44: AA 4300C - AA 9230C 
	A9: AA 9213C - AA 9999C, AA 0001U - AA 3319U
	A38: AA 3320U - AA 7169U 
	A2: AA 7170U - AA 9999U, AA 0001V - AA 0497V 
	A3: AA 0498V - AA 3785V 
	A4: AA 3786V - AA 7041V 
	A7: AA 7042V - AA 9999V, AA 0001W - AA 0237W
	A8: AA 0238W - AA 3517W 
	A5: AA 3518W - AA 6725W 
	A46: AA 6726W - AA 9999W 

	A47: AA 0001X - AA 3350X 
	A28: AA 3351X - AA 6600X 
	A48: AA 6601X - AA 9961X 
	A41: AA 9962X - AA 9999X, HF,HG,0-350HH 
	A14: 351HH,HJ,0-500HK 
	A13: 501HK,HL,HM, 
	A16: HN,HP,0-399HR, 
	A31: 400HR, HS, 0-799HT
	A1: 800HT,HU,HV,0-500HW
	A15: 501HW,HY,JA
	A45: JC
	A33: CA,CC,0-890CE 
	A34: 891CE,CF,CG,0-645CH 
	A10:646CH,CJ,CK,0-370CL 
	A11:371CL,CM,CN 
	A12:CP,CR,CS 
	A27:CT,CU,CV 
	A6:CW,CX,CY, 

	A18 - AA 001T, AA 001U,AA 001V-900V 
	A42: A2* tag:2022

	B6: AA 0001E-AA 4659E
	B12: AA 4660E- AA 9000E
	B13: AA 9002E,AA 0-3339F
	B14: AA 3340F - AA 7610F
	B15: AA 7611F - AA 9999F ,AA 0001G-AA 1808G
	B16: AA 1809G - AA 6265G
	B21: AA 6266G- AA 9999G ,AA 0001H-AA 0629H
	B24: AA 0630H- AA 4810H
	B25: AA 4811H- AA 8749H
	B26: AA 8750H-AA 9999H, AA 0001J-AA 3129J
	B27: AA 3130J- AA 7110J
	B28: AA 7111J, AA 0-AA 1040K
	B30: AA 1041K - AA 5030K
	B32:AA 5031K- AA 9070K
	B33: AA 9071K - AA 9999K,AA 0001L- AA 3120L
	B41:AA 901V,001W,AE*,AJ*,AM*,AN*,A2* tag:2023,A2* tag:2024
	B37: AA 3122L-AA 7220L
	B39:AA 7221L-AA 9999L
	B43: AA 0002N- AA 1810N
	B35: AA 1811N- AA 5279N
	B44: AA 5280N- AA 8679N
	B46: AA 8680N- AA 9999N, AA 0001P-AA 1915P
	B17: AA 1916P- AA 4969P
	B48: AA 4970P- AA 8049P
	B3: AA 8050P- AA 9999P, AA 0001S- AA 1192S
	B2: AA 1193S - AA 4319S
	B20: AA 4320S- AA 7469S
	B9: AA 7470S- AA 9999S,AA 0000T- AA 0576T
	B10: AA 0577T - AA 3820T

	B11: AA 3821T - AA 6889T
	B31: AA 6890T - AA 9999T
	B18: AA 0001Y - AA 2999Y
	B45: AA 6181Y - AA 9440Y
	B36: AA 9441Y , AA,AC,0-760AE
	B4: AA 761AE,AF,AG,AH,0-250AJ
	B5: AA 251AJ,AK,AL,0-420AM
	B19: AA 421AM,AN,AP,0-600AR
	B22: AA 601AR,AS,AT,0-615AU
	B29: AA 617AU,AV,AW
	B38: AX,AY,AA 3889-AA 4611
	B8: AA 0001-AA 3888

	B34: JE
	B47: EA,EC
	B7: EE,0-199EF
	B23: AA 200EF, EG,EH,0-120EJ
	B40: AA 121EJ,EK,EL,0-119EM
	B42: AA 120EM,EN,EP

	C01 ER, ES, 001-630ET
	C02 631ET, EU, EV,0-370EW
	C03 371EW, EY, FA,
	C04 FC, FE, 0-690FF
	C05 691FF,FG,FH
	C06 FJ, FK
	C07 FL, FM, 0-499FN
	C08 500FN, FP, FR
	C09 FS, FT, 0-499FU
	C10 AA 3000Y - AA 6180Y
	C11 500FU, FV, FW
	C12 FY, GA, 0-499GC
	C13 AAA*,AAU*,AAA*
	C24 AGR*,AHA*,AKL*,AL*,ALM*,AMN*,AS*,ASE*,ASI*,ASK*,ASU*,AWM*,AZA*,C..-PR..
	C23 PS..-ZZZ..

	C14 500GC, GE, 0-499GF
	C15 500GF, GG, GH
	C16 GJ, GK,0-300GL
	C17 301GL, GM,0-600GN
	C18 601GN, GP,0-800GR
	C19 801GR, GS,GT

	C20 GU,GV,0-370GW
	C21 371GW,GY,0-700HA
	C22 701HA,HC,HE
	C27 AA 0001M - AA 4330M
	C28 AA 4331M - AA 8169M
	C29 AA 8170M - AA 9999M, EX
	C25 FX, GX, 0-600HX
	C26 AA 001R-999R, AA 0-999S, AA 001L, 601HX

	A42 skrócone sprawdzaj_na_końcu
	A42 indywidualne

	P1PA1 AAA 0005-AAA 3647
	P1PB1 AAA 3652-AAA 6715
	P1PC1 AAA 6716-AAA 9366
	P1PD1 AAA 9377-AAA 9997, AAB 0015-AAB 2291
	P1PA2 AAB 2304-AAB 5561
	P1PB2 AAB 5569-AAB 8835
	P1PC2 AAB 8837-AAB 9996,AAH 0004-AAH 1635
	P1PD2 AAH 1376-AAH 4610
	P1PA3 AAH 4615-AAH 8024
	P1PB3 AAH 8034-AAH 9992, AAK 0013-AAK 0964
	P1PC3 AAK 0975-AAK 4051
	P1PD3 AAK 4056-AAK 7573
	P1PA4 AAK 7582-AAK 9998, AAM 0002-AAM 1241
	P1PB4 AAM 1271-AAM 4613
	P1PC4 AAM 4614-AAM 7854
	P1PD4 AAM 7858-AAM 9995,AAO 0004-AAO 1453
	P1PA5 AAO 1460-AAO 4879
	P1PB5 AAO 4890-AAO 8523
	P1PC5 AAO 8562-AAO 9978,AAZ 0013-AAZ 1519
	P1PD5 AAZ 1523-AAZ 3366, AA 001C-AA 299C
	P1PA6 AA 301C-AA 955C
	P1PB6 AA 956C-AA 998C,AA 001F-AA 668F
	P1PC6 AA 669F-AA 998F, AA 001A-AA640A
	P1PD6 AA 642A-AA 997A, AA 001E-AA 640E

	P2LD1 AA 644E-AA 998E,AA 001G-AA 597G
	P2LC1 AA 602G-AA 996G,AA 001H-AA 508H
	P2LB1 AA 511H-AA 998H,AA 004J-AA 386J
	P2LA1 AA 388J-AA 997J,AA 006K-AA 195K
	P2LD2 AA 196K-AA 994K,AA 001M-AA 052M
	P2LC2 AA 053M-AA 857M
	P2LB2 AA 858M-AA 998M,AA 003N-AA 627N
	P2LA2 AA 628N-AA 999N,AA 003P-AA 398P
	P2LD3 AA 400P-AA 999P,AAM 0006-AAM 0917
	P2LC3 AAM 0932-ATM 5269
	P2LB3 ATM 5274-ATM 9904
	P2LA3 ATM 9928-ATM 9999,ATN 9902-ATN 9992, ATO 0007-ATO 3479
	P2LD4 ATO 3480-ATO 6858
	P2LD4 ATO 6868-ATO 9997, ATZ 0008-ATZ 0292
	P2LB4 ATZ 0303-ATZ 3526
	P2LA4 ATZ 3532-ATZ 6829
	P2LD5 ATZ 6832-ATZ 9836
	P2LC5 ATZ 9839-ATZ 9995, ATV 0002-ATV 2626
	P2LB5 ATV 2629-ATV 9899

	P2PA1 AKO 0017-AKO 9989,AKS 0038-AKS 3476
	P2PB1 AKS 3482-AKS 9992,AKV 0027-AKV 3192
	P2PC1 AKV 3193-AKV 9995,AKX 0051-AKX 3130
	P2PD1 AKX 3145-AKX 9994,ATB 0031-ATB 1600
	P2PA2 ATB 1601-ATB 9999,ATC 0008-ATC 0398
	P2PB2 ATC 0434-ATC 6847
	P2PC2 ATC 6851-ATC 9989,ATG 0002-ATG 3667
	P2PD2 ATG 3669-ATG 9997,ATH 0011-ATH 0623
	P2PA3 ATH 0624-ATH 6260
	P2PB3 ATH 6262-ATH 9996,ATK 0009-ATK 2236
	P2PC3 ATK 2299-ATK 9090
	P2PD3 ATK 9095-ATK 9978,AA 0001A-AA 0699A
	P2PA4 AA 0702A-AA 1413A
	P2PB4 AA 1415A-AA 2089A
	P2PC4 AA 2090A-AA 2703A
	P2PD4 AA 2704A-AA 3477A
	P2PA5 AA 3479A-AA 4274A
	P2PB5 AA 4277A-AA 4906A
	P2PC5 AA 4907A-AA 5694A
	P2PD5 AA 5696A-AA 6463A
	P2PA6 AA 6465A-AA 7223A
	P2PB6 AA 7224A-AA 7781A
	P2PC6 AA 7782A-AA 8414A
	P2PD6 AA 8416A-AA 9093A

	P3LD5 AA 9095A-AA 9751A
	P3LD6 AA 9752A-AA 9999A

	P3PA1 AKA 0044-AKA 4699,AKG 7005-AKG 8745,AKH 0201-AKH 3068,AKL 0001-AKL 0098,AKN 2001-AKN 2357,AKA 003C-AKA 924C,AKA 005B-AKA 122B
	P3PB1 AKA 138B-AKA 991B,AKA 023D-AKA 812D,ATT 2508-ATT 9999,ATJ 2201-ATJ 6143,AKA 814D-AKA 998D,AKA 007E-AKA 974E,AKA 003Y-AKA 994Y,AKB 101B-AKB 630B,AKB 002C-AKB 990C,AKB 835E-AKB 835E,AKB 804H-AKB 804H,AKB 003R-AKB 657R
	P3PC1 AKB 658R-AKB 997R,AKB 001S-AKB 998S,AKD 003E-AKD 990E,AKD 002G-AKD 994G,AKD 005H-AKD 747H
	P3PD1 AKD 750H-AKD 996H,AKD 054K-AKD 849K,AKM 001B-AKM 098B,AKP 009B-AKP 919B,AKP 007C-AKP 995C,AKP 002X-AKP 868X,AKB 021V-AKB 595V
	P3PA2 AKB 475V-AKB 998V,AKB 019Y-AKB 996Y,AKB 002Z-AKB 989Z,AKC 023B-AKC 492B,AKD 005B-AKD 998B,AKD 004C-AKD 984C,AKD 004D-AKD 992D,ATX 0302-ATX 0973
	P3PB2 ATX 0979-ATX 4433
	P3PC2 ATX 4435-ATX 7790
	P3PD2 ATX 7797-ATX 8998,ATI 0001-ATI 2474
	P3PA3 ATI 2476-ATI 6867,AAJ 1002-AAJ 2308
	P3PB3 AAJ 2309-AAJ 5536,AKF 4703-AKF 5327
	P3PC3 AKF 5328-AKF 6501,AKA 0008-AKA 4447
	P3PD3 AKA 4449-AKA 6198,AKK 2004-AKK 2500
	P3PA4 AA 01A-AA 99A,AA 01C-AA 98C,AA 01E-AA 99E
	P3PB4 AA 01F-AA 99F,AA 01G-AA 59G,AF 35-AF35,AJ 83-AJ 83,AA 4504-AA 4504

	tag:g19
	P4LD1 AA 6597V-AA 9661V
	P4LC1 AA 9669V-AA 9992V, AA 0001W-AA 2620W
	P4LB1 AA 2626W-AA 6431W
	P4LA1 AA 6424W-AA 9980W, AA 0027X-AA 0929X
	P4LD2 AA 0935X-AA 5334X
	P4LC2 AA 5341X-AA 9982X,AA 0002Y-AA 0502Y
	P4LB2 AA 0503Y-AA 5556Y
	P4LA2 AA 5592Y-AA 9999Y, AA 002AA-AA 483AA
	P4LD3 AA 485AA-AA 969AA,AA 005AC-AA 987AC,AA 032AE-AA 999AE,AA 001AF-AA 985AF,AA 008AG-AA 584AG
	P4LC3 AA 592AG-AA 964AG,AA 008AH-AA 963AH,AA 037AJ-AA 966AJ,AA 014AK-AA 986AK,AA 002AL-AA 713AL
	P4LB3 AA 740AL-AA 999AL,AA 008AM-AA 995AM,AA 006AN-AA 997AN,AA 017AP-AA 947AP,AA 004AR-AA 948AR, AA 002AS-AA 476AS,AA 477AS-AA 996AS
	P4LA3 AA 477AS-AA 996AS,AA 086AT-AA 992AT,AA 015AV-AA 874AV,AA 046AV-AA 986AV,AA 002AW-AA 972AW,AA 001AX-AA 413AX
	P4LD4 AA 447AX-AA 991AX,AA 019AY-AA 993AY,AA 021CA-AA 910CA,AA 041CC-AA 993CC,AA 007CE-AA 942CE,AA 008CF-AA 966CF,AA 006CG-AA 968CG,AA 031CH-AA 675CH
	P4LC4 AA 761CH-AA 987CA,AA 014CJ-AA 983CJ,AA 030CK-AA 951CK,AA 300CL-AA 883CL,AA 015CM-AA 701CM,AA 059CN,AA 298CP-AA 872CP,AA 036CR-AA 669CR,AA 113CS-AA 456CS,AA 045A-AA 846A,AA 005C-AA 912C,AA 217E-AA 981E,AA 055F-AA 999F,AA 036G-AA 997G,AA 009H-AA 990H,AA 040J-AA 454J
	P4LB4 AA 455J-AA 998J,AA 026K-AA 996K,AA 006L-AA 948L,AA 017M-AA 991M,AA 027N-AA 840N
	P4LA4 AA 849N-AA 996N,AA 016P-AA 996P,AA 003R-AA 582R,AA 0207-AA 3905,AAA 1252-AAA 9434,AAB 0632-AAB 9998,AAH 0466-AAH 4004
	P4LD5 AAH 4098-AAH 9813,AAJ 1143-AAJ 3036,AAK 0202-AAK 9379,AAM 0043-AAM 9032,AAO 0121-AAO 9631,AAZ 0032-AAZ 3079,AKA 3940-AKA 3950,AKK 2200-2200,AKN 2209-2208,AKO 3092-3092,AKX 1233-1233,ATB 4261-ATB 6195,ATC 0703-ATC 7569,ATG 0049-ATG 8344,ATH 0408-ATH 9636,ATI 2516-ATI 3582,ATJ 2210-ATJ 5445,ATK 6831-6831,ATM 0922-ATM 7293,AT 04005-04005,ATO 0565-ATO 5650,ATT 6491-ATT 9976,ATZ 0819-ATZ 9061,ATV 0304-ATV 9885,ATX 0318-ATX 1857
	P4LC5 ATX 2000-ATX 8958,A047-A286,AA 22A-AA 55A,AA 51E-51E,AMC 001-001,A2 2852-A2 5219,AA 02-AA 05

	P4PA1 AA 00072-AA 14523
	P4PB1 AA 14660-AA 24790
	P4PC1 AA 24920-AA 35574
	P4PD1 AA 36067-AA 46672
	P4PA2 AA 46696-AA 53961
	P4PB2 AA 53999-AA 63662
	P4PC2 AA 63705-AA 72193
	P4PD2 AA 72236-AA 80001
	P4PA3 AA 80008-AA 87219
	P4PB3 AA 87290-AA 93995
	P4PC3 AA 94036-AA 99912,AA 0013A-AA 0558A
	P4PD3 AA 0563A-AA 9993A,AA 0074C-AA 1658C
	P4PA4 AA 1680C-AA 7718C
	P4PB4 AA 7781C-AA 9986C,AA 0008E-AA 3162E
	P4PC4 AA 3186E-AA 8191E
	P4PD4 AA 8195E-AA 9974E,AA 0027F-AA 4278F
	P4PA5 AA 4288F-AA 9758F
	P4PB5 AA 9783F-AA 9939F,AA 0020G-AA 5177G
	P4PC5 AA 5200G-AA 9857G
	P4PD5 AA 9870G-AA 9927G,AA 0006H-AA 3498H
	P4PA6 AA 3508H-AA 8546H
	P4PB6 AA 8563H-AA 9988H,AA 0017J-AA 2986J
	P4PC6 AA 3029J-AA 7558J
	P4PD6 AA 7623J-AA 9970J,AA 0033K-AA 2570K

	P5LD1 AA 2581K-AA 7884K
	P5LC1 AA 7891K-AA 9983K,AA 0047L-AA 2256L
	P5LB1 AA 2284L-AA 6968L
	P5LA1 AA 6985L-AA 9980L,AA 0021M-AA 1849M
	P5LD2 AA 1851M-AA 5875M
	P5LC2 AA 5898M-AA 7806M,AA 0036N-AA 4304N
	P5LB2 AA 4341N-AA 8416N
	P5LA2 AA 8461N-AA 9987N,AA 0008P-AA 2858P
	P5LD3 AA 2863P-AA 6937P
	P5LC3 AA 6959P-AA 9998P,AA 0056R-AA 0920R
	P5LB3 AA 0946R-AA 4879R
	P5LA3 AA 4889R-AA 7350R
	P5LD4 AA 7362R-AA 9983R,AA 0070S-AA 0266S
	P5LC4 AA 0307S-AA 3024S
	P5LB4 AA 3328S-AA 6703S
	P5LA4 AA 6757S-AA 9966S,AA 0001T-AA 0415T
	P5LD5 AA 0441T-AA 4358T
	P5LC5 AA 4369T-AA 7996T
	P5LB5 AA 8001T-AA 9989T,AA 001U-AA 1458U
	P5LA5 AA 1489U-AA 4658U
	P5LD6 AA 4671U-AA 7326U
	P5LC6 AA 7327U-AA 9966U,AA 0002V-AA 0233V
	P5LB6 AA 0236V-AA 3423V
	P5LA6 AA 3427V-AA 6577V

	tag:
	P5PA1 AA 00006-AA 01260
	P5PB1 AA 01261-AA 02582
	P5PC1 AA O2583-AA 04037
	P5PD1 AA 04038-AA 05425
	P5PA2 AA 05428-AA 06674
	P5PB2 AA 06675-AA 08077
	P5PC2 AA 08088-AA 09330
	P5PD2 AA 09332-AA 10446
	P5PA3 AA 10448-AA 11885
	P5PB3 AA 11887-AA 13106
	P5PC3 AA 13111-AA 14446
	P5PD3 AA 14449-AA 15786
	P5PA4 AA 15790-AA 17067
	P5PB4 AA 17068-AA 18341
	P5PC4 AA 18351-AA 19676
	P5PD4 AA 19677-AA 20871
	P5PA5 AA 20884-AA 22356
	P5PB5 AA 22375-AA 23664
	P5PC5 AA 23674-AA 24997
	P5PD5 AA 25002-AA 26146
	P5PA6 AA 26154-AA 27443
	P5PB6 AA 27445-AA 28646
	P5PC6 AA 28648-AA 29789
	P5PD6 AA 29792-AA 30908

	tag:g20
	P6LD1 AA 00171-AA 23607
	P6LC1 AA 23722-AA 41888
	P6LB1 AA 41930-AA 54881
	P6LA1 AA 55098-AA 66061
	P6LD2 AA 66063-AA 77771
	P6LC2 AA 77791-AA 87283
	P6LB2 AA 87286-AA 97576
	P6LA2 AA 97662-AA 99999,AA 0012A-AA 9990A,AA 0051C-AA 1716C
	P6LD3 AA 1772C-AA 9977C,AA 0010E-AA 0203E
	P6LC3 AA 0244E-AA 8413E
	P6LB3 AA 8433E-AA 9998E,AA 0454F-AA 6116F
	P6LA3 AA 6141F-AA 9952F,AA 0019G-AA 4840G
	P6LD4 AA 4863G-AA 9933G,AA 0027H-AA 3311H
	P6LC4 AA 3379H-AA 9977H,AA 0001J-AA 0377J
	P6LB4 AA 0464J-AA 6159J
	P6LA4 AA 6222J-AA 9988J, AA 0002K-AA 2474K
	P6LD5 AA 2595K-AA 9969K
	P6LC5 AA 0091L-AA 6539L
	P6LB5 AA 6546L-AA 9984L,AA 0282M-AA 3540M
	P6LA5 AA 3558M-AA 8890M,AA 0014N-AA 1296N
	P6LD6 AA 1321N-AA 7221N
	P6LC6 AA 7232N-AA 9995N,AA 0042P-AA 3394P
	P6LB6 AA 3448P-AA 9679P
	P6LA6 AA 9709P-AA 9993P,AA 0062R-AA 5715R

	P6PA1 AA 5339R-AA 9988R,AA 0033S-AA 0390S
	P6PB1 AA 0414S-AA 5237S
	P6PC1 AA 5258S-AA 9928S,AA 0027T-AA 0143T
	P6PD1 AA 0153T-AA 4617T
	P6PA2 AA 4654T-AA 9096T
	P6PB2 AA 9098T-AA 9991T,AA 0003V-AA 3478U
	P6PC2 AA 3508U-AA 8610U
	P6PD2 AA 8614U-AA 9974U,AA 0016V-AA 2726V
	P6PA3 AA 2784V-AA 7349V
	P6PB3 AA 7391V-AA 9990V,AA 0005W-AA 2249W
	P6PC3 AA 2251W-AA 5862W
	P6PD3 AA 5863W-AA 9006W
	P6PA4 AA 9014W-AA 9976W,AA 0005X-AA 2712X
	P6PB4 AA 2748X-AA 6449X
	P6PC4 AA 6451X-AA 9993X
	P6PD5 AA 0036Y-AA 4364Y
	P6PA5 AA 4381Y-AA 9592Y
	P6PB5 AA 9594Y-AA 9996Y,AA 016AA-AA 986AA,AA 026AC-AA 949AC,AA 004AE-AA 981AE,AA 008AF-AA 989AF,AA 011AG-AA 981AG
	P6PC5 AA 010AH-AA 972AH,AA 001AJ-AA 995AJ,AA 007AK-AA 999AK,AA 019AL-AA 996AL,AA 011AM-AA 971AM,AA 007AN-AA 253AN
	P6PD5 AA 261AN-AA 984AN,AA 006AP-AA 978AP,AA 018AR-AA 983AR,AA 024AS-AA 997AS,AA 010AT-AA 964AT,AA 020AU-AA 991AU
	P6PA6 AA 051AV-AA 998AV,AA 028AW-AA 980AW,AA 021AX-AA 999AX,AA 036AY-AA 963AY,AA 008CA-AA 994CA,AA 001CC-AA 437CC
	P6PB6 AA 464CC-AA 978CC,AA 018CE-AA 943CE,AA 040CF-AA 991CF,AA 001CG-AA 997CG,AA 004CH-AA 997CH
	P6PC6 AA 022CJ-AA 964CJ,AA 011CK-AA 993CK,AA 022CL-AA 978CL,AA 025CM-AA 986CM,AA 015CN-AA 501CN
	P6PD6 AA 508CN-AA 987CN,AA 004CP-AA 985CP,AA 003CR-AA 997CR,AA 004CS-AA 994CS

	P7LD1 AA 002CT-AA 994CT,AA 011CU-AA 981CU,AA 014CB-AA 974CV,AA 019CW-AA 994CW,AA 014CX-AA 340CX
	P7LC1 AA 371CX-AA 902CX,AA 012CY-AA 987CY,AA 003EA-AA 999EA,AA 048EC-AA 972EC,AA 016EE-AA 973EE,AA 046EF-AA 339EF
	P7LB1 AA 341EF-AA 995EF,AA 095EG-AA 980EG,AA 070EH-AA 990EH,AA 014EJ-AA 918EJ,AA 005EK-AA 974EK,AA 069EL-AA 935EL,AA 286EM-AA 926EM,AA 210EN-AA 705EN,AA 038EP-AA 594EP,AA 279ER-AA 916ER,AA 035ES-035ES,AA 013A-AA 943A,AA 226C-AA 877C,AA 125E-AA 896E,AA 005F-AA 996F,AA 152G-AA 994G,AA 098H-AA 904H,AA 019J-AA 906J,AA 030K-AA 231K
	P7LA1 AA 272K-AAAA 988K,AA 007L-AA 985L,AA 005M-AA 919M,AA 006N,AA-AA 989N,AA 001P-AA 988P,AA 004ER-AA 306ER
	P7LD2 AA 308R-AA 999R,AA 013T-AA 557T,AA 0490-AA 4045,AAA 2607-AAA 9786,AAB 0579-AAB 7381,AAH 1499-AAH 9442,AAJ 1128-AAJ 4892,AAK 0431-AAJ 9610,AAM 0960-AAM 9591,AAO 0231-AAO 8628
	P7LC2 AAO 8700-AAO 9750,AAZ 0179-AAZ 3221,AKA 2360-AKA 6119,AKN 2237,AKO 1234-AKO 7368,AKV 3067,AKX 4048-AKX 7134,ATC 6431,ATB 1090-ATB 1090,ATH 2135-ATH 9214,ATI 6184-ATI 6864,ATJ 2294-ATJ 2294,ATM 6654-ATM 9198,ATO 5470-ATO 7280,ATT 5044-ATT 9980,ATV 0641-ATV 9782,ATX 0678-ATX 8778,ATZ 0440-ATZ 9840,A 001-A 471,AA 12C-AA 43C,AA 40E-AA 62E,A2 5246-A2 5400,AA 07-AA 11,A2 4345-A2 5087
	P7LB2 A2 5089-A2 5245
	tag:g21
	P7LB2 AA 00143-AA 20213
	P7LA2 AA 20220-AA 37298
	P7LD3 AA 37311-AA 50308
	P7LC3 AA 50414-AA 61236
	P7LB3 AA 61278-AA 74191
	P7LA3 AA 74220-AA 85918
	P7LD4 AA 86025-AA 95394
	P7LC4 AA 95440-AA 99832,AA 0011C-AA 5840C
	P7LB4 AA 5911C-AA 9895C,AA 0209E-AA 4326E
	P7LA4 AA 4390E-AA 9997E,AA 0016F-AA 1999F
	P7LD5 AA 2067F-AA 9082F
	P7LC5 AA 9144F-AA 9906F,AA 0077G-AA 6449G
	P7LB5 AA 6498G-AA 9957G,AA 0045H-AA 2478H
	P7LA5 AA 2521H-AA 9999H
	P7LD6 AA 0025J-AA 5549J
	P7LC6 AA 5566J-AA 9949J,AA 0060K-AA 2825K
	P7LB6 AA 2832K-AA 9417K
	P7LA6 AA 9430K-AA 9987K,AA 0030L-AA 5775L

	P7PA1 AA 5776L-AA 9996L, AA 0034N-AA 2881N
	P7PB1 AA 2933N-AA 9069N
	P7PC1 AA 9139N-AA 9981N,AA 0049P-AA 5222P
	P7PD1 AA 5389P-AA 9983P
	P7PA2 AA 0041R-AA 4984R
	P7PB2 AA 4988R-AA 9999R
	P7PC2 AA 0001S-AA 53332S
	P7PD2 AA 5346S-AA 9998S
	P7PA3 AA 0002T-AA 5014T
	P7PB3 AA 5044T-AA 9542T
	P7PC3 AA 9542T-AA 9983T,AA 0038U-AA4343U
	P7PD3 AA 4348U-AA 8600U
	P7PD4 AA 9775V-AA 9997V,AA 0026W-AA 3779W
	P7PA5 AA 3780W-AA 8000W
	P7PB5 AA 8003W-AA AA 9983W,AA 0002X-AA 1768X
	P7PC5 AA 1778X-AA 5647X
	P7PD5 AA 5675X-AA 8804X
	P7PA6 AA 8826X-AA 9965X,AA 0010Y-AA 2348Y
	P7PB6 AA 2352Y-AA AA 4859Y
	P7PC6 AA 4860Y-AA 7254Y
	P7PD6 AA 7258Y-AA 9998Y

	P8LD1 AA 0031A-AA 9994A,AA 0025M-AA 4215M
	P8LC1 AA 4219M-AA 8955M
	P8LB1 AA 8970M-AA 9930M, AA 003AA-AA 996AA,AA 003AC-AA 979AC,AA 002AE-AA 405AE
	P8LA1 AA 406AE-AA 998AE,AA 005AF-AA 993AF,AA 003AG-AA 823AG
	P8LD2 AA 843AG-AA 978AG,AA 020AH-AA 994AH,AA 003AJ-AA 997AJ,AA 005AK-AA 729AK
	P8LC2 AA 754AK-AA 998AK,AA 001AL-AA 987AL,AA 012AM-AA 994AM,AA 005AN-AA 375AN
	P8LB2 AA 387AN-AA 988AN,AA 001AP-AA 999AP,AA 002AR-AA 901AR
	P8LA2 AA 902AR-AA 994AR,AA 010AS-AA 951AS,AA 002AT-AA 998AT,AA 002AU-AA 980AU,AA 012AV-AA 977AV
	P8LD3 AA 005AW-AA 996AW,AA 034AX-AA 994AX,AA 007AY-AA 972AY,AA 001CA-AA 990CA,AA 023CC-AA 349CC
	P8LC3 AA 387CC-AA 995CC,AA 002CE-AA 995CE,AA 004CF-AA 963CF,AA 013CG-AA 970CG,AA 017CH-AA 489CH
	P8LB3 AA 500CH-AA 991CH,AA 026CJ-AA 981CJ,AA 024CK-AA 974CK,AA 016CL-AA 999CL,AA 002CM-AA 980CM
	P8LA3 AA 022CN-AA 983CN,AA 024CP-AA 986CP,AA 002CR-AA 986CR,AA 024CS-AA 970CS,AA 018CT-AA 814CT
	P8LD4 AA 818CT-AA 953CT,AA 038CU-AA 993CU,AA 006CV-AA 995CV,AA 011CW-AA 977CW,AA 031CX-AA 999CX
	P8LC4 AA 002CY-AA 999CY,AA 001EA-AA 955EA,AA 059EC-AA 007EE-AA 991EE
	P8LB4 AA 036EF-AA 997EF,AA 005EG-AA 992EG,AA 012EH-AA 996,AA 032EJ-AA 438EJ
	P8LA4 AA 486EJ-AA 979EJ,AA 033EK-AA 990EK,AA 002EL-AA 993EL,AA 028EM-AA 939EM,AA 012EN-AA 419EN
	P8LD5 AA 437EN-AA 994EN,AA 001EP-AA 998EP,AA 007ER-AA 999ER,AA 015ES-AA 853ES
	P8LC5 AA 859ES-AA 995ES,AA 003ET-AA 997ET,AA 048EU-AA 487EU,AA 505EU-AA 998EU,AA 004EV-AA 993EV,AA 001EW-AA 998EW,AA 062EX-AA 554EX
	P8LB5 AA 002EY-AA 993EY,AA 029FA-AA 980FA,AA 001FC-AA 997FC,AA 008FE-AA 966FE,AA 003FF-AA 966FF
	P8LA5 AA 027FG-AA 923FG,AA 007FH-AA 997FH,AA 004FJ-AA 986FJ,AA 006FK-AA 990FK,AA 019FL-AA 920FL,AA 012FM-AA 971FM,AA 014FN-AA 999FN,AA 061FP,AA 016FR-AA 981FR
	P8LD6 AA 026FS-AA 856FS,AA 014FT-AA 985FT,AA 118FU-AA 926FU,AA 384FV-AA 669FV,AA 394A-AA 958A,AA 036C-AA 981C,AA 113E-AA 985E,AA 006F-AA 935F,AA 026G-AA 998G,AA 100J-AA 967J,AA 004K-AA 981K,AA 017L-AA 993L,AA 010M-AA 971M,AA 004N-AA 997N,AA 002P-AA 412P
	P8LC6 AA 420P-AA 998P,AA 039R-AA 992R,AA 006S-AA 388S,AA 002U-AA 644U,AA 0178-AA 3075
	P8LB6 AA 3419-AA 4283,AAA 0890-AAA 8214,AAB 0482-AAB 9513,AAH 0263-AAH 8760,AAJ 1046-AAJ 2943,AAK 0820-AAK 8977,AAM 0255-AAM 9802,AAO 0625-AAO 9550,AAZ 0045-AAZ 3250,AKA 0178-AKA 3598,AKH 2126-AKH 2126,AKN 2225-AKN 2225,AKO 6479-AKO 6379,AKP 012X-AKP 012X,AKX 0385-AKX 4499,ATG 7569-ATG 7569,ATH 5681-ATH 8220,ATI 6622-ATI 6622,ATJ 2264-ATJ 2264,ATK 3713-ATK 3713,ATO 0504-ATO 9968,ATT 6476-ATT 6476,ATV 0024-ATV 9793,ATX 1196-ATX 8964,A 009-A 499,A1 62-A1 62,A1 H3-A1 H3,A2 C8-A2 C8,A2 G9-A2 G9,A3 G1-A3 G1,A4 H5-A4 H5
	P8LA6 A6 F9-A9 G3,AA 40C-AA 93C,AA 07E-AA 75E,AA 31F-AA 47F,A2 2552-A2 5500
	`;

	const RAW_STORAGE_MAP = `
	A:
	entry:100
	   P   T
	1      113
	2  62
	3  1
	4  50
	5      93
	6      77
	7  42
	8  77
	9  46
	10     20
	11 81
	12     56
	13     12
	14 34
	15     16
	16 70
	17     44
	18     97
	19     24
	20 30
	21     32
	22 66
	23 38
	24 58
	25     4
	26     101
	27 22
	28 54
	29     81
	30     85
	31     36
	32     40
	33 85
	34     105
	35     60
	36 26
	37     89
	38 89
	39     72
	40     28
	41     8
	42     48
	43     52
	44     64
	45     1
	46     109
	47 93
	48     68
	
	B:
	entry:100
	   P   T
	1  115
	2      13
	3      65
	4      25
	5      33
	6      113
	7  81
	8      37
	9      21
	10 27
	11 63
	12     105
	13     85
	14 31
	15     101
	16 23
	17     109
	18     45
	19 39
	20     81
	21 47
	22 85
	23     57
	24     5
	25     41
	26     77
	27     61
	28 1
	29 43
	30     97
	31 67
	32     29
	33 51
	34 71
	35     89
	36 55
	37 95
	38     93
	39 89
	40 77
	41     1
	42 59
	43     53
	44     9
	45     49
	46     17
	47 35
	48     69

	C:
	entry:99
	   P   T
	1  85
	2      83
	3  77
	4      67
	5      1
	6      116
	7  65
	8      95
	9      103
	10     75
	11 120
	12 116
	13     120
	14 73
	15 69
	16 1
	17 30
	18 26
	19     29
	20     110
	21     79
	22 81
	23     99
	24     91
	25     59
	26     63
	27 61
	28     71
	29     87
	`;

	const P_SECTION_SHELVES_NUMBERED_UNTIL = 360;
	const P_SECTION_SHELF_REGEX = /(?<id>[0-9]+)(?<side>[a-z])(?<column>[a-z])(?<row>[0-9])/;
	const P_SECTION_SHELF_REGEX_GRP_CNT = P_SECTION_SHELF_REGEX.toString().split("?").length-1;
	const P_SECTION_NUMBER_OF_SHELVES_ON_ONE_CABINET_SIDE = 24
	const P_SECTION_FIRST_SHELF = 1
	const P_SECTION_COLUMNS = ['a','b','c','d'];
	
	const PERSONAL_KEYWORD = 'indywidualne';
	const PERSONAL_REGEX = /^[a-zA-Z][0-9][a-zA-Z].+$/;
	const SHORTENED_KEYWORD = 'skrócone';
	const SHORTENED_VALUES = [3,4];

	var storage = raw_storage_key_to_array(RAW_STORAGE_KEY);
	storage.map = raw_storage_map_to_array(RAW_STORAGE_MAP);
	
	function is_numeric(str) {
		if (typeof str != 'string') return false
		return !isNaN(str) && !isNaN(parseFloat(str))
	}

	function raw_storage_key_to_array(input_text) {
		function is_separator(input_character) {
			return input_character.trim()=='' || input_character==':' || input_character=='-';
		}

		let output = {
			pattern: [],
			sections: [],
			tags_section: {},
			tags_local: [],
		};
		let output_deferred = {
			pattern: [],
		};
		let tag_for_the_current_storage_section = '';
		const TAG_KEYWORD = 'tag:';
		const DEFER_KEYWORD = 'sprawdzaj_na_końcu';
		const LINE_KEYWORDS = {
			'tag':'tag:',
			'defer':'sprawdzaj_na_końcu'
		};

		Object.keys(STORAGE_SECTION_NAMES).forEach(current_section_key=>{
			if (current_section_key != NON_MATCHING_SECTION_KEY)
				output.tags_section[current_section_key] = [];
		});

		input_text.toLowerCase().split(/\r?\n/).forEach(line => {
			line = line.trim();
			if (line.length == 0)
				return;

			if (line.substring(0,LINE_KEYWORDS['tag'].length) == LINE_KEYWORDS['tag']) {
				tag_for_the_current_storage_section = line.substring(LINE_KEYWORDS['tag'].length);
				return;
			}

			let i = 0;
			while(i<line.length && !is_separator(line[i])) i++;

			let j = 0;
			while(j<i && !is_numeric(line[j])) j++;

			let section = line.substring(0,j);
			let shelf = line.substring(j,i);
			
			if (is_numeric(shelf))
				shelf = parseInt(shelf);
			
			if (!output.sections.includes(section))
				output.sections.push(section);

			while(i<line.length && is_separator(line[i])) i++;
			let input_patterns = line.substr(i).split(/,/);

			input_patterns.forEach(input_pattern => {
				input_pattern = input_pattern.trim();
				let tag_for_the_current_line = '';
				let defer = false;

				// First cut off special options from the line
				Object.keys(LINE_KEYWORDS).forEach(key=>{
					let keyword = LINE_KEYWORDS[key];
					let start = input_pattern.indexOf(keyword);
					if (start > -1) {
						let end = start + input_pattern.substring(start).search(/\s|$/);
						let split = [input_pattern.substring(start,start+keyword.length), input_pattern.substring(start+keyword.length, end)];
						input_pattern = input_pattern.substring(0,start).trim() + input_pattern.substring(end).trim();

						switch(split[0]) {
							case LINE_KEYWORDS['tag'] : {
								tag_for_the_current_line = split[1];
								output.tags_local.push({
									'shelf'  : shelf,
									'section': section,
									'range'  : input_pattern.replace('*',''),
									'name'   : tag_for_the_current_line
								});
							}; break;

							case LINE_KEYWORDS['defer'] : {
								defer = true;
							}; break;
						}
					}
				});

				if (input_pattern.length == 0)
					return;

				let range = input_pattern.split(/-/).map(input => {
					input = input.trim();
					if (input.length == 0)
						return;
						
					let output = {};

					if (input.substring(input.length-1) == '*') {
						output.prefix = input.substring(0,input.length-1);
						return output;
					}

					if (input.substring(input.length-2) == '..') {
						output.prefix_range = input.substring(0,input.length-2);
						return output;
					}

					if (input.substring(0,PERSONAL_KEYWORD.length) == PERSONAL_KEYWORD) {
						output.regex = PERSONAL_REGEX;
						return output;
					}

					if (input.substring(0,SHORTENED_KEYWORD.length) == SHORTENED_KEYWORD) {
						output.length_min = SHORTENED_VALUES[0];
						output.length_max = SHORTENED_VALUES[1];
						return output;
					}
					
					let tokens = input.trim().split(/\s/);
					output.prefix = tokens.length>1 ? tokens[0] : '';
					output.number = '';
					output.suffix = '';

					tokens.at(-1).match(/[a-zA-Z]+|[0-9]+/g).forEach(item => {
						if (is_numeric(item) && output.number.length==0)
							output.number = item;
						else 
							if (!is_numeric(item) && output.suffix.length==0)
								output.suffix = item;
					});
					
					return output;
				});

				if (!range)
					return;
					
				let pattern = {
					section: section,
					shelf: shelf,					
				};

				if (tag_for_the_current_storage_section != '' || tag_for_the_current_line != '') {
					pattern.tag = tag_for_the_current_line!='' ? tag_for_the_current_line : tag_for_the_current_storage_section;
				}

				if (range.length > 1 && range[1].hasOwnProperty('prefix') && range[1].prefix!='') {
					pattern.prefix = range[1].prefix;
				} else
					if (range.length > 0 && range[0].hasOwnProperty('prefix')) {
						pattern.prefix = range[0].prefix!='' ? range[0].prefix : DEFAULT_PREFIX;
					}

				if (range.length > 1 && range[1].hasOwnProperty('suffix') && range[1].suffix!='') {
					pattern.suffix = range[1].suffix;
				} else
					if (range.length > 0 && range[0].hasOwnProperty('suffix')) {
						pattern.suffix = range[0].suffix;
					}

				if (range[0].hasOwnProperty('number')) {
					// input is two numbers (e.g 0-100)
					if (range.length > 1 && range[1].number!='' && range[0].number!='') {
						pattern.start = parseInt(range[0].number);
						pattern.end = parseInt(range[1].number);
						pattern.digits = range[1].number.length;
					} else
						// input is one number (e.g 100)
						if (range.length > 0 && range[0].number!='') {
							pattern.digits = range[0].number.length;
							pattern.start = parseInt(range[0].number);
							pattern.end = parseInt('9'.repeat(pattern.digits));
						} else
							// input is letters (e.g AA)
							if (pattern.suffix != '' && pattern.suffix.length<INPUT_ID_MAX_DIGITS) {
								pattern.start = 1;
								pattern.end = parseInt('9'.repeat(INPUT_ID_MAX_DIGITS - pattern.suffix.length));
								pattern.digits = pattern.end.toString().length;
							}
				}

				if (range.length > 0 && range[0].hasOwnProperty('prefix_range')) {
					pattern.prefix_start = range[0].prefix_range;
					pattern.prefix_end = range[0].prefix_range;

					if (range.length > 1 && range[1].hasOwnProperty('prefix_range')) {
						pattern.prefix_end = range[1].prefix_range;
					}
				}

				if (range[0].hasOwnProperty('length_min') && range[0].hasOwnProperty('length_max')) {
					pattern.length_min = range[0].length_min;
					pattern.length_max = range[0].length_max;
				}
				
				if (range[0].hasOwnProperty('regex')) {
					pattern.regex = range[0].regex;
				}

				(defer ? output_deferred : output).pattern.push(pattern);

				if (tag_for_the_current_storage_section.length > 0 && !output.tags_section[section].includes(tag_for_the_current_storage_section)) {
					output.tags_section[section].push(tag_for_the_current_storage_section);
				}
			});
		});

		output_deferred.pattern.forEach(pattern => {
			output.pattern.push(pattern);
		})

		return output;
	}

	function raw_storage_map_to_array(input_text) {
		let output = {};
		let section = '';
		let shelves_below_the_entry_point = 0;
		let shelves_above_the_entry_point = 0;
		const ENTRY_KEYWORD = 'entry:';

		input_text.toLowerCase().split(/\r?\n/).forEach(line => {
			line = line.trim();
			if (line.length == 0)
				return;

			// Start of section
			let colon = line.indexOf(':');
			if (colon >= 0) {
				if (line.substring(0,ENTRY_KEYWORD.length) == ENTRY_KEYWORD) {
					output[section].entry_point = parseInt(line.substring(ENTRY_KEYWORD.length));
				} else {
					if (Object.keys(STORAGE_SECTION_NAMES).includes(line.substring(0,colon))) {
						section = line.substring(0,colon);
						output[section] = {entry_point:0, entry_is_up:false};
						shelves_below_the_entry_point = 0;
						shelves_above_the_entry_point = 0;
					}
				}
			// Shelf
			} else {
				tokens = line.split(/[\s]+/);
				if (tokens.length >= 2 && is_numeric(tokens[0]) && is_numeric(tokens[1])) {
					let shelf    = is_numeric(tokens[0]) ? parseInt(tokens[0]) : tokens[0];
					let position = parseInt(tokens[1]);
					output[section][shelf] = position;

					if (position >= output[section].entry_point)
						shelves_above_the_entry_point++;
					else
						shelves_below_the_entry_point++;
						
					output[section].entry_is_up = shelves_below_the_entry_point > shelves_above_the_entry_point;
				}
			}
		});

		return output;
	}

	function preprocess_input_text(input_area) {
		let new_text         = '';
		let cursor_position  = input_area.selectionStart;
		let line_number      = 0;
		let line_with_cursor = -1;
		let word_index       = -1;
		let character_index  = -1;

		for (let i=0; i<=input_area.value.length; i++) {
			if (i == cursor_position) {
				line_with_cursor = line_number;

				// if cursor is on the last line that is empty then assume it is on the previous line
				if (i>0 && i == input_area.value.length && (input_area.value[i-1] == '\r' || input_area.value[i-1] == '\n')) {
					line_with_cursor--;
				}
			}

			if (i < input_area.value.length) {
				if (input_area.value[i] == '\r' || input_area.value[i] == '\n') {
					word_index = -1;
					character_index = -1;

					if (input_area.value[i] == '\n')
						line_number++;
				} else {
					if (input_area.value[i].trim() !== '') {
						character_index++;

						if (character_index == 0)
							word_index++;

						if (word_index==0 && character_index==0 && is_numeric(input_area.value[i])) {
							new_text += DEFAULT_PREFIX;
							cursor_position += 2;
						}
					} else {
						character_index = -1;
					}
				}
	
				new_text += word_index==0 ? input_area.value[i].toUpperCase() : input_area.value[i];
			}
		}

		input_area.value = new_text;
		input_area.setSelectionRange(cursor_position, cursor_position);
		return line_with_cursor;
	}

	function sort_numbers_to_shelves(input_text, storage, continue_search=false, selected_line=-1) {
		let output = {
			sections: {non_matching: []},
			total_count: 0,
			last_item: {section:'',index:0},
			duplicates: [],
		};
		let initial_list = {
			last_item: {
				section: '', 
				shelf: '', 
				text: '',
			}
		};
		storage.sections.forEach(section => {
			output.sections[section] = []; 
			initial_list[section]    = [];
		});

		function compare_letters(start, target, end) {
			if (target == DEFAULT_PREFIX)
				return false;
			
			if (target == start || target == end)
				return true;

			let array = [start, target, end];
			array.sort();
			return target == array[1];
		}

		function parse_id_number(input, custom_prefix='') {
			let output = {
				prefix: '',
				number: -1,
				digits: 0,
				suffix: '',
			};

			let i = 0;

			if (custom_prefix.length > 0) {
				if (input.substring(0,custom_prefix.length) == custom_prefix) {
					i = custom_prefix.length;
				}
			} else {
				while (i<input.length && !is_numeric(input[i]) && i<INPUT_ID_PREFIX_MAX_LEN) i++;
			}
			output.prefix = input.substring(0,i);

			let j = input.length - 1;
			while (i>=0 && !is_numeric(input[j]) && j>input.length-1-INPUT_ID_SUFFIX_MAX_LEN) j--;
			output.suffix = j<input.length-1 ? input.substring(j+1) : '';

			let temp = input.substring(i, j+1);
			if (is_numeric(temp)) {
				output.number = parseInt(temp);
				output.digits = temp.length;
			} else {
				output.suffix = '';
			}

			return output;
		}

		function compare_prefix(current_id, current, pattern_prefix) {
			if (pattern_prefix!=DEFAULT_PREFIX && /[0-9]/.test(pattern_prefix)) {
				return parse_id_number(current_id, pattern_prefix).prefix == pattern_prefix;
			} else {
				return current.prefix == pattern_prefix;
			}
		}

		function compare_number(current_id, current, storage_pattern) {
			if (storage_pattern.prefix!=DEFAULT_PREFIX && /[0-9]/.test(storage_pattern.prefix)) {
				let current_new = parse_id_number(current_id, storage_pattern.prefix);
				return current_new.number >= storage_pattern.start && current_new.number<=storage_pattern.end && current_new.digits==storage_pattern.digits;
			} else {
				return current.number >= storage_pattern.start && current.number<=storage_pattern.end && current.digits==storage_pattern.digits;
			}
		}

		input_text.split(/\r?\n/).forEach((line, line_number) => {
			let words = line.trim().split(/\s+/);
			if (words.length == 0)
				return;

			let current_id = words[0].toLowerCase();
			if (current_id.length == 0) 
				return;

			let tags     = [];
			let comments = [];
			words.forEach((word,index)=> {
				if (index > 0) {
					if (/^[a-zA-Z0-9]/.test(word)) {
						tags.push(word.toLowerCase());
					} else {
						comments.push(word);
					}
				}
			});

			let line_preprocessed = current_id + (tags.length>0 ? ' ' : '') + tags.join(' ');
			let current = parse_id_number(current_id);
			let matched = false;
			
			for(let i=0; i<storage.pattern.length && (!matched || continue_search); i++) {
				if (
					((!storage.pattern[i].hasOwnProperty('length_min') || !storage.pattern[i].hasOwnProperty('length_max')) ||
					(current_id.length >= storage.pattern[i].length_min && current_id.length <= storage.pattern[i].length_max))
					&&
					(!storage.pattern[i].hasOwnProperty('regex') ||
					storage.pattern[i].regex.test(current_id))
					&&
					((!storage.pattern[i].hasOwnProperty('prefix_start') && !storage.pattern[i].hasOwnProperty('prefix_end')) || 
					compare_letters(storage.pattern[i].prefix_start,current.prefix,storage.pattern[i].prefix_end))
					&&
					(!storage.pattern[i].hasOwnProperty('prefix') ||
					compare_prefix(current_id, current, storage.pattern[i].prefix))
					&&
					(!storage.pattern[i].hasOwnProperty('suffix') ||
					current.suffix == storage.pattern[i].suffix)
					&&
					((!storage.pattern[i].hasOwnProperty('start') || !storage.pattern[i].hasOwnProperty('end') || !storage.pattern[i].hasOwnProperty('digits')) ||
					compare_number(current_id, current, storage.pattern[i]))
					&&
					((!storage.pattern[i].hasOwnProperty('tag') && tags.length==0) ||
					tags.includes(storage.pattern[i].tag))
				) {
					if (!initial_list[storage.pattern[i].section].hasOwnProperty(storage.pattern[i].shelf)) {
						initial_list[storage.pattern[i].section][storage.pattern[i].shelf] = [];
					}

					initial_list[storage.pattern[i].section][storage.pattern[i].shelf].forEach(item => {
						if (item.text == line_preprocessed && !output.duplicates.includes(line_preprocessed)) {
							output.duplicates.push(line_preprocessed);
						}
					});

					initial_list[storage.pattern[i].section][storage.pattern[i].shelf].push({
						ruleid: i,
						text: line_preprocessed,
						tokens: [words[0], tags, comments]
					});
					
					if (line_number == selected_line) {
						initial_list.last_item = {
							section: storage.pattern[i].section, 
							shelf: storage.pattern[i].shelf, 
							text: line_preprocessed
						};
					}
					output.total_count++;
					matched = true;
				}
			}
			
			if (!matched) {
				let found = false;
				for(let j=0; j<output.sections.non_matching.length && !found; j++) {
					if (output.sections.non_matching[j].text == line_preprocessed) {
						found = true;
					}
				}

				if (found && !output.duplicates.includes(line_preprocessed)) {
					output.duplicates.push(line_preprocessed);
				}

				if (line_number == selected_line) {
					initial_list.last_item.section = '';
					initial_list.last_item.shelf   = '';
					initial_list.last_item.text    = '';
					output.last_item.section       = 'non_matching';
					output.last_item.index         = output.sections.non_matching.length;
				}

				output.sections.non_matching.push({
					text: line_preprocessed,
					id: words[0],
					tags: tags,
					comments: comments
				});
				
				output.total_count++;
			}
		});
        
		storage.sections.forEach(section => {
			if (!Object.keys(storage.map).includes(section)) {
				let shelves = Object.keys(initial_list[section]);

				if (section == 'p') {
					shelves.sort(function(x,y) {
						let a = P_storage_relative_shelf_location_to_absolute_sort(x);
						let b = P_storage_relative_shelf_location_to_absolute_sort(y);
						return a==b ? 0 : (a<b ? -1 : 1);
					})
				} else {
					shelves.sort();
				}
				
				shelves.forEach(shelf => {
					initial_list[section][shelf].forEach(item => {
						if (initial_list.last_item.section==section && initial_list.last_item.shelf==shelf && initial_list.last_item.text==item.text) {
							output.last_item.section = section;
							output.last_item.index   = output.sections[section].length;
						}

						output.sections[section].push({
							shelf: shelf,
							id: item.tokens[0],
							tags: item.tokens[1],
							comments: item.tokens[2]
						});
					});
				});
				return;
			}

			// Sort items within the shelves
			Object.keys(initial_list[section]).forEach(shelf => {
				initial_list[section][shelf].sort(function(x,y) {
					if (x.ruleid < y.ruleid) return -1;
					if (x.ruleid > y.ruleid) return 1;
					if (x.text < y.text) return -1;
					if (x.text > y.text) return 1;
					return 0;
				});
			});

			// The optimal path is to go from the top shelf to the bottom shelf (assuming entry point is closer to the top)
			// Shelf location is taken from the predefined storage map
			let shelves_sorted = Object.keys(initial_list[section]).sort(function(x,y) {
				x = parseInt(x);
				y = parseInt(y);
				if (storage.map[section][x] < storage.map[section][y]) return 1;
				if (storage.map[section][x] > storage.map[section][y]) return -1;
				return 0;
			});

			if (!storage.map[section].entry_is_up) {
				shelves_sorted.reverse();
			}
			
			shelves_sorted.forEach(shelf => {
				initial_list[section][shelf].forEach(item => {
					if (initial_list.last_item.section==section && initial_list.last_item.shelf==shelf && initial_list.last_item.text==item.text) {
						output.last_item.section = section;
						output.last_item.index   = output.sections[section].length;
					}

					output.sections[section].push({
						shelf: shelf,
						id: item.tokens[0],
						tags: item.tokens[1],
						comments: item.tokens[2]
					});
				});
			});
		});
		
		return output;
	}

	function P_storage_format_relative_shelf_location(input) {
		let m = input.toLowerCase().match(P_SECTION_SHELF_REGEX);
		if (!m)
			return;
		let cabinet = m.groups;
		
		if (cabinet.length < P_SECTION_SHELF_REGEX_GRP_CNT) 
			return '';
			
		return 'Szafa #' + cabinet.id + ' ' +
			(cabinet.side=='l' ? 'lewa' : 'prawa') + 
			' rząd ' + cabinet.row +
			' kol ' + (P_SECTION_COLUMNS.findIndex(x => x==cabinet.column) + 1);
	}
	
	function P_storage_relative_shelf_location_to_absolute(input) {
		/*
		Convert shelf relative location (cabinet number, cabinet side, column number, row number) to a shelf number
		Shelves are numbered left to right, from the top row to bottom
		*/
		let m = input.toLowerCase().match(P_SECTION_SHELF_REGEX);
		if (!m)
			return;
		let cabinet = m.groups;
		
		if (cabinet.length < P_SECTION_SHELF_REGEX_GRP_CNT) 
			return '';

		let column = P_SECTION_COLUMNS.findIndex(x => x==cabinet.column);
		let number_of_cabinet_sides = parseInt(cabinet.id) * 2 - (cabinet.side=='l' ? 1 : 0);

		// on the left side of a cabinet we start counting columns from the end
		if (cabinet.side == 'l') {
			column = P_SECTION_COLUMNS.length - 1 - column;
		}

		return P_SECTION_FIRST_SHELF + P_SECTION_NUMBER_OF_SHELVES_ON_ONE_CABINET_SIDE*(number_of_cabinet_sides-1) + P_SECTION_COLUMNS.length*(parseInt(cabinet.row)-1) + column;
	}

	function P_storage_relative_shelf_location_to_absolute_sort(input) {
		/*
		Convert shelf relative location (cabinet number, cabinet side, column number, row number) to a shelf number
		Shelves are numbered top to bottom, starting from the farthest columns (counting on both sides of the aisle) to the nearest
		*/
		let m = input.toLowerCase().match(P_SECTION_SHELF_REGEX);
		if (!m)
			return;
		let cabinet = m.groups;
		
		if (cabinet.length < P_SECTION_SHELF_REGEX_GRP_CNT) 
			return '';

		let column = P_SECTION_COLUMNS.length - 1 - P_SECTION_COLUMNS.findIndex(x => x==cabinet.column); //always reverse column index because we start with the farthest columns
		let row    = parseInt(cabinet.row);

		// in one aisle we treat both sides as a single table (4 columns by 12 rows)
		let number_of_rows_in_this_aisle = P_SECTION_NUMBER_OF_SHELVES_ON_ONE_CABINET_SIDE * 2 / P_SECTION_COLUMNS.length;

		let aisle = parseInt(cabinet.id) - (cabinet.side=='l' ? 1 : 0);
		let first_shelf_in_this_aisle = P_SECTION_FIRST_SHELF;
		
		if (aisle == 0) {
			number_of_rows_in_this_aisle = 6; // first aisle has only one side (4 columns by 6 rows)
		} else {
			// left side of the next cabinet counts as rows 7-12
			if (cabinet.side == 'l') {
				row += 6;
			}

			// sum shelves in the previous aisles
			// first aisle has only 24 shelves (not 48) so we start with (P_SECTION_FIRST_SHELF + P_SECTION_NUMBER_OF_SHELVES_ON_ONE_CABINET_SIDE)=25
			// and then multiply number of shelves in an aisle (24*2=48) by all the remaining aisles (aisle-1)
			first_shelf_in_this_aisle = P_SECTION_FIRST_SHELF + P_SECTION_NUMBER_OF_SHELVES_ON_ONE_CABINET_SIDE + (P_SECTION_NUMBER_OF_SHELVES_ON_ONE_CABINET_SIDE*2)*(aisle-1);
		}

		return first_shelf_in_this_aisle + number_of_rows_in_this_aisle*column + (row-1);    
	}

	input.addEventListener('input', function(e){	
		let line_with_cursor = preprocess_input_text(e.target);
		document.getElementById('output').innerHTML = generate_html_table(sort_numbers_to_shelves(e.target.value, storage, document.getElementById('continuesearch').checked, line_with_cursor));
		localStorage.setItem("input_text",e.target.value);
	});

	document.getElementById('continuesearch').addEventListener('input', function(e){
		document.getElementById('input').dispatchEvent(new Event('input'));
	});
	
	document.getElementById('key_info_map_toggle_content').addEventListener('change', function(e){
		document.getElementById('key_info_map_display_sort').dispatchEvent(new Event('change'));
	});

	var strike_list = [];
	document.addEventListener('DOMContentLoaded', function(event) {
		let textarea = document.getElementById('input');
		textarea.focus();
		
		let cursor = localStorage.getItem('cursor');
		if (cursor) {
			cursor = JSON.parse(cursor);
			setTimeout(() => {textarea.setSelectionRange(cursor[0], cursor[1]);}, 10);	// second argument will not work on load so that's why timeout
		}

		let loaded_strike_list = localStorage.getItem('strike_list');
		if (loaded_strike_list) {
			strike_list = JSON.parse(loaded_strike_list);
		} else {
			strike_list = [];
		}

		textarea.value = localStorage.getItem('input_text');
		if (textarea.value.length > 0) {
			let line_with_cursor = preprocess_input_text(textarea);
			document.getElementById('output').innerHTML = generate_html_table(sort_numbers_to_shelves(textarea.value, storage, document.getElementById('continuesearch').checked, line_with_cursor));
			localStorage.setItem('input_text',textarea.value);
		}

		// Tags information paragraph
		let tags_field = document.getElementById('tags_list');
		let tags_all   = [];

		Object.keys(storage.tags_section).forEach(key=>{
			storage.tags_section[key].forEach(item=>{
				tags_all.push(item);
			});
		});

		tags_field.innerHTML = tags_all.join('<br>');

		storage.tags_local.forEach(tag => {
			tags_field.innerHTML += '<br>' + tag.name + ' (tylko dla ' + tag.range + ')';
		})

		if (tags_all.length > 0) {
			document.getElementById('tags_example').innerHTML = DEFAULT_PREFIX + '12345 ' + tags_all[0];
		}

		// Key display select
		let key_info_select      = document.getElementById('key_info_select');
		let key_info_select_sort = document.getElementById('key_info_select_sort');
		let key_info_display     = document.getElementById('key_info_display');
		let key_info_select_tag  = document.getElementById('key_info_select_tag');
		
		let key_info_map_display_sort   = document.getElementById('key_info_map_display_sort');
		let key_info_map_display        = document.getElementById('key_info_map_display');
		let key_info_map_toggle_content = document.getElementById('key_info_map_toggle_content');

		storage.sections.forEach(section_name => {
			let option = document.createElement('option');
    		option.value = section_name;
    		option.innerHTML = STORAGE_SECTION_NAMES[section_name];
    		key_info_select.appendChild(option);
		});

		key_info_select.addEventListener('change', (event) => {display_storage_key(event.target, key_info_select, key_info_select_tag, key_info_select_sort, key_info_display); key_info_map_display_sort.dispatchEvent(new Event('change'));});
		key_info_select_sort.addEventListener('change', (event) => {display_storage_key(event.target, key_info_select, key_info_select_tag, key_info_select_sort, key_info_display)});
		key_info_select_tag.addEventListener('change', (event) => {display_storage_key(event.target, key_info_select, key_info_select_tag, key_info_select_sort, key_info_display)});
		
		key_info_map_display_sort.addEventListener('change', (event) => {display_storage_map(event.target, key_info_select, key_info_map_toggle_content.checked, key_info_map_display_sort, key_info_map_display)});
	});

	input.addEventListener('selectionchange', function(e){
		localStorage.setItem('cursor', JSON.stringify([e.target.selectionStart,e.target.selectionEnd]));
		
		let line_start = e.target.value.lastIndexOf('\n', e.target.value[e.target.selectionStart] ? e.target.selectionStart-1 : e.target.selectionStart);
		if (line_start == -1)
			line_start = 0;

		let line_end = e.target.value.indexOf('\n', e.target.selectionStart);
		if (line_end == -1)
			line_end = e.target.value.length;

		let selected_id = get_id_without_comment(e.target.value.substring(line_start,line_end));
		if (selected_id.length == 0) {
			// special case: if input ends with empty new lines and the cursor is there then select last non-empty line in the input
			selected_id = (function() {

				// first check if there's no text after the current selection
				for (i=e.target.selectionStart; i<e.target.value.length; i++) {
					if (e.target.value.charCodeAt(i) > 32) {
						return '';
					}
				}
	
				// look for last non-empty line
				for (i=e.target.selectionStart; i>=0; i--) {
					if (i == 0) {
						return '';
					}
	
					if (e.target.value.charCodeAt(i) > 32) {
						line_start = e.target.value.lastIndexOf('\n', i);
						if (line_start == -1)
							line_start = 0;

						line_end = i + 1;
						return get_id_without_comment(e.target.value.substring(line_start,line_end));
					}
				}
	
				return '';
			})();
		}

		const rows = document.querySelector('#'+OUTPUT_TABLE_ID+'>tbody')?.rows;
		if (!rows)
			return;

		Array.from(rows).forEach(row => {
			const cells = Array.from(row.cells);
				cells.forEach(cell => {
					if (selected_id == '') {
						cell.classList.remove("color_flash");
					} else {
						let colon = cell.textContent.indexOf(':');
						let current_id = get_id_without_comment(colon ? cell.textContent.slice(colon+1) : cell.textContent);
	
						if (current_id == selected_id) {
							cell.classList.add("color_flash");
						} else {
							cell.classList.remove("color_flash");
						}
					}
			});
		});
	});

	function display_storage_key(current_control, storage_section_select, storage_tag_select, sort_type_select, target_text_field) {
		let new_html = '<table><thead><tr><th>Półka</th><th>Zawartość</th></tr><tbody>';

		if (storage.sections.indexOf(storage_section_select.value) >= 0) {
			let list_of_keys_to_sort = [];

			if (current_control == storage_section_select) {
				while (storage_tag_select.options.length > 1)
					storage_tag_select.remove(1);

				storage.tags_section[storage_section_select.value].forEach(tag => {
					let option = document.createElement('option');
					option.value = tag;
					option.innerHTML = tag;
					storage_tag_select.appendChild(option);
				});
			}

			storage.pattern.forEach((p,index) => {
				if (p.section == storage_section_select.value && storage_tag_select.value==(p.hasOwnProperty('tag') ? p.tag : "")) {
					let value_to_sort_by = '';
					
					switch(sort_type_select.value) {
						case 'default' : value_to_sort_by=index; break;
						case 'shelf'   : value_to_sort_by=parseInt(p.shelf); break;
						case 'suffix'  : 
							value_to_sort_by = 
								(p.hasOwnProperty('digits') && p.hasOwnProperty('suffix'))
								? p.suffix.length.toString() + '_' + p.digits + '_' + p.suffix
								: '';
							break;
					}
					
					list_of_keys_to_sort.push({
						sort_by: value_to_sort_by,
						pattern_index: index
					});
				}
			});

			list_of_keys_to_sort
			.sort(function (a, b) {
				return ((a.sort_by < b.sort_by) ? -1 : ((a.sort_by == b.sort_by) ? 0 : 1));
			})
			.forEach(item => {
				let formatted = format_pattern(storage.pattern[item.pattern_index])
				new_html += '<tr><td>'+formatted.shelf+'</td><td>'+formatted.content+'</td></tr>';
			});
		}

		target_text_field.innerHTML = new_html + '</tbody></table>';
	}
	
	function display_storage_map(current_control, storage_section_select, show_shelf_content, sort_type_select, target_text_field) {
		let key_info_map = document.getElementById('key_info_map');
		if (!key_info_map)
			return;
		
		if (storage.map.hasOwnProperty(storage_section_select.value)) {
			key_info_map.style.display = 'block';
			
			const SPACE_BETWEEN_ID_AND_CONTENT_LIST = 5;
			let patterns_formatted = {};
			let new_html = '';
			
			if (show_shelf_content) {
				storage.pattern.forEach(current_pattern => {
					if (current_pattern.section == storage_section_select.value) {
						if (!patterns_formatted.hasOwnProperty(current_pattern.shelf)) {
							patterns_formatted[current_pattern.shelf] = [];
						}
						
						patterns_formatted[current_pattern.shelf].push(format_pattern(current_pattern,0).content);
					}
				});
			}
			
			new_html += '<table class="key_info"></thead>';
		
			switch(sort_type_select.value) {
				case 'place': {
					let places      = {};
					let max_columns = 1;
					
					Object.keys(storage.map[storage_section_select.value]).forEach(shelf => {
						if (is_numeric(shelf) || shelf=='entry_point') {
							let current = storage.map[storage_section_select.value][shelf];
							
							if (shelf == 'entry_point') {
								shelf = 'okno';
							}
							
							if (places.hasOwnProperty(current)) {
								places[current].push(shelf);
								
								if (places[current].length > max_columns) {
									max_columns = places[current].length;
								}
							} else {
								places[current] = [shelf];
							}
						}
					});
					
					
					new_html += '<tr><th>Miejsce</th>' + '<th>Półka</th>'.repeat(max_columns) + '</tr></thead><tbody>';

					Object.keys(places).sort(function(a,b){
						a = parseInt(a);
						b = parseInt(b);
						return a==b ? 0 : a>b ? -1 : 1;
					}).forEach(place=>{
						new_html += '<tr><td>' + place + '</td>';
						
						for (let i=0; i<max_columns; i++) {
							new_html += '<td>'
							contents = '';
							
							if (i < places[place].length) {
								 new_html += (places[place][i]).padEnd(show_shelf_content ? SPACE_BETWEEN_ID_AND_CONTENT_LIST : 0,'\u00A0');
								 
								 if (show_shelf_content && patterns_formatted.hasOwnProperty([places[place][i]])) {
									contents += patterns_formatted[places[place][i]].join(', ');
								 }
							}
							
							new_html += contents + '</td>'
						}
						
						new_html += '</tr>';
					});
					
					new_html += '</tbody></table>'
				} break;
				
				case 'shelf': {
					new_html += '<tr><th>Półka</th><th>Miejsce</th></thead></tbody>';
					
					Object.keys(storage.map[storage_section_select.value]).sort(function(a,b){
						a = parseInt(a);
						b = parseInt(b);
						return a==b ? 0 : a<b ? -1 : 1;
					}).forEach(shelf => {
						if (is_numeric(shelf)) {
							new_html += '<tr><td>' + shelf + '</td><td>' + storage.map[storage_section_select.value][shelf].toString().padEnd(show_shelf_content ? SPACE_BETWEEN_ID_AND_CONTENT_LIST : 0,'\u00A0');
							
							if (show_shelf_content && patterns_formatted.hasOwnProperty(shelf)) {
								new_html += patterns_formatted[shelf].join(', ');
							}

							new_html += '</td></tr>';
						}
					});
					
					new_html += '</tbody></table>'
				} break;
			}
			
			target_text_field.innerHTML = new_html;
		} else {
			key_info_map.style.display = 'none';
		}
		
	}

	function format_pattern(p, verbose=true) {
		let shelf  = '';
		let output = {shelf:'',content:''};

		if (verbose) {
			if (p.section == 'p') {
				shelf = P_storage_relative_shelf_location_to_absolute(p.shelf);
				if (shelf > P_SECTION_SHELVES_NUMBERED_UNTIL) {
					output.shelf = P_storage_format_relative_shelf_location(p.shelf);
				} else {
					output.shelf = shelf.toString().padStart(3,'0');
				}
			} else {
				output.shelf = p.shelf.toString().padStart(2,'0');
			}
		}

		if (p.hasOwnProperty('start') && p.hasOwnProperty('end')) {
			if (verbose) {
				output.content += 
					p.prefix.toUpperCase() + p.start.toString().padStart(p.digits,'0') + '<b>' + p.suffix.toUpperCase() + '</b>' + 
					' - ' + 
					p.prefix.toUpperCase() + p.end.toString().padStart(p.digits,'0') + '<b>' + p.suffix.toUpperCase() + '</b>';
			} else {
				if (p.prefix != DEFAULT_PREFIX) {
					output.content += p.prefix.toUpperCase();
				}
				
				if (p.start == 1 && p.end==parseInt("".padStart(p.digits,'9'))) {
					output.content += '<b>' + p.suffix.toUpperCase() + '</b>';
				} else {
					output.content += p.start.toString() + '-' + p.end.toString().padStart(p.digits,'0') + '<b>' + p.suffix.toUpperCase() + '</b>';
				}
			}
		} 
		else if (p.hasOwnProperty('regex')) {
			if (String(p.regex) == String(PERSONAL_REGEX))
				output.content += 'indywidualne';
			else 
				output.content += 'zaczyna się od: ' + p.regex;
		}
		else if (p.hasOwnProperty('length_min') && p.hasOwnProperty('length_max')) {
			if (p.length_min==SHORTENED_VALUES[0] && p.length_max==SHORTENED_VALUES[1])
				output.content += 'skrócone';
			else
				output.content += 'długość: ' + p.length_min + '-' + p.length_max;
		} 
		else if (p.hasOwnProperty('prefix_start') && p.hasOwnProperty('prefix_end')) {
			output.content += p.prefix_start.toUpperCase() + '... - ' + p.prefix_end.toUpperCase();
		}
		else {
			if (p.hasOwnProperty('prefix'))
				output.content += p.prefix.toUpperCase();

			if (p.hasOwnProperty('tag'))
				output.content += ' <i>' + p.tag + '</i>';
		}

		return output;
	}
	
	var drag_and_drop_field       = document.getElementById('draganddrop_field');
	var drag_and_drop_last_target = null;

	window.addEventListener('dragenter', function(event) {
		drag_and_drop_last_target            = event.target;
		drag_and_drop_field.style.visibility = '';
		drag_and_drop_field.style.opacity    = 1;
	});

	window.addEventListener('dragleave', function(event) {
		if (event.target === drag_and_drop_last_target || event.target === document) {
			drag_and_drop_field.style.visibility = 'hidden';
			drag_and_drop_field.style.opacity    = 0;
		}
	});
	
	function drop_handler(event, field) {
		event.preventDefault();
		parse_dropped_files(event.dataTransfer);
		field.style.visibility = 'hidden';
		field.style.opacity    = 0;
	}

	function parse_dropped_files(input) {
		if (input.files.length == 0)
			return;

		let textarea = document.getElementById('input');
		textarea.value = '';

		for (var i=0; i<input.files.length; i++) {
			(function(file, is_last) {
				const reader = new FileReader();
				reader.onload = function() {
					switch(file.name.slice(-3).toLowerCase()) {
						case 'csv' : {
							let wanted_column = -1;

							reader.result.split(/\r?\n/).forEach((line,line_number) => {
								line = line.trim();
								
								if (line.length > 0) {
									let column_number = 0;
									let column_start  = 0;

									for (let i=0; i<=line.length; i++) {
										if (i==line.length || line[i] == ';' || line[i] == ',') {
											column_number++;

											if (line_number == 0) {
												if (line.substring(column_start,i).toLowerCase() == CSV_IMPORT_DATA_FROM_COLUMN.toLowerCase()) {
													wanted_column = column_number - 1;
												}
											} else 
												if (column_number == wanted_column+1 && wanted_column >= 0) {
													textarea.value += line.substring(column_start,i).trim() + '\n';
												}

											column_start = i + 1;
										}
									}
								}
							});
							break;
						}

						case 'txt' : {
							textarea.value += reader.result.trim() + '\n'; 
							break;
						}

						// Requires read-excel-file.js (currently disabled)
						case 'xslx' : {
							readXlsxFile(file).then(function(rows) {							
								rows.forEach(row => {
									if (row.length >= 7) {
										textarea.value += row[6] + '\n';
									}
								});
							});
							break;
						}
					}

					if (is_last) {
						textarea.dispatchEvent(new Event('input'));
					}
				}

				reader.readAsText(file, "UTF-8");
			})(input.files[i], i==input.files.length-1);
		}
	}


	function generate_html_table(sorted_numbers) {
		if (sorted_numbers.total_count == 0) {
			return '';
		}
		
		let sections_with_items = [];
		Object.keys(STORAGE_SECTION_NAMES).forEach(section => {
			if (sorted_numbers.sections.hasOwnProperty(section) && sorted_numbers.sections[section].length > 0) {
				sections_with_items.push(section);
			}
		});

		let html_head = '';
		let html_foot = '<tr>';
		let item_count_in_largest_section = 0;

		sections_with_items.forEach(section => {
			html_head += '<th>' + STORAGE_SECTION_NAMES[section] + '</th>';
			html_foot += '<td>' + sorted_numbers.sections[section].length + '</td>';
			
			if (sorted_numbers.sections[section].length > item_count_in_largest_section) {
				item_count_in_largest_section = sorted_numbers.sections[section].length;
			}
		});

		html_foot += '</tr><tr><td colspan="5">Suma: ' + sorted_numbers.total_count + '</td></tr>';

		let html_rows = '';
		let new_strike_list = [];
		
		for(let row=0; row<item_count_in_largest_section; row++) {
			let html_row = '';

			sections_with_items.forEach(section => {
				if (sorted_numbers.sections[section] && sorted_numbers.sections[section][row]) {
					let shelf = sorted_numbers.sections[section][row].shelf ? sorted_numbers.sections[section][row].shelf : '';
					
					if (section == 'p') {
						let shelf_num = P_storage_relative_shelf_location_to_absolute(shelf);
						shelf = shelf_num <= P_SECTION_SHELVES_NUMBERED_UNTIL ? shelf_num.toString().padStart(3,'0') : P_storage_format_relative_shelf_location(shelf);
					}
					
					let shelf_pad = is_numeric(shelf) ? shelf.padStart(2,'0') : shelf;
					let id        = sorted_numbers.sections[section][row].id ? sorted_numbers.sections[section][row].id : sorted_numbers.sections[section][row]; //match is an object, notmatching is a string
					let tags      = sorted_numbers.sections[section][row].tags ? sorted_numbers.sections[section][row].tags.join(' ') : '';
					let comments  = sorted_numbers.sections[section][row].comments ? sorted_numbers.sections[section][row].comments.join(' ') : '';

					let text_without_comment = 
						(shelf ? (shelf_pad+': ') : '') +
						id +
						(tags.length>0 ? (' '+tags) : '');

					let style = '';

					if (strike_list.includes(text_without_comment)) {
						style = ' style="text-decoration:line-through;" ';
						new_strike_list.push(text_without_comment);
					}

					html_row += 
						'<td ' + style + 'onclick="toggle_strike(this)">' + 
						(shelf ? shelf_pad+': ' : '') +
						id +
						(tags.length>0 ? (' <i>'+tags+'</i>') : '') +
						(comments.length>0 ? (' <span style="font-size:x-small">'+comments+'</span>') : '') +
						'</td>';

					if (sorted_numbers.last_item.section == section && sorted_numbers.last_item.index == row) {
						let last_result = document.getElementById('last_result');
						if (last_result) {
							last_result.innerHTML = 
								id + (tags.length>0 ? (' '+tags) : '') + 
								' - <span class="highlight">' + 
								STORAGE_SECTION_NAMES[section] + 
								(shelf ? (': ' + shelf) : '') + 
								'</span>';
						}
					}
				} else {
					html_row += '<td></td>'
				}
			});
			
			html_rows += '<tr>' + html_row + '</tr>';
		}

		let html_p = sorted_numbers.duplicates.length > 0
			? '<p><small><b>Duplikaty:</b> ' + sorted_numbers.duplicates.join(', ') + '</small></p>'
			: '';

		strike_list = new_strike_list;
		localStorage.setItem('strike_list', JSON.stringify(strike_list));

		return '<table id=\''+OUTPUT_TABLE_ID+'\'><caption>' + 
			generate_file_name('. :','<span style="float:left">'+document.title+'</span>') + 
			'</caption><thead><tr>' + html_head + '</tr></thead><tbody>' + 
			html_rows + '</tbody><tfoot>' + html_foot + '</tfoot></table>' + html_p;
	}

	function generate_file_name(punctuation='_--', prefix='lista') {
		var today = new Date();
		var dd    = String(today.getDate()).padStart(2, '0');
		var mm    = String(today.getMonth() + 1).padStart(2, '0');
		var hh    = String(today.getHours()).padStart(2, '0');
		var min   = String(today.getMinutes()).padStart(2, '0');
		var yyyy  = today.getFullYear();
		return prefix + yyyy + punctuation[0] + mm + punctuation[0] + dd + punctuation[1] + hh + punctuation[2] + min;
	}

	// Requires write-excel-file (currently not using it)
	function generate_spreadsheet(sorted_numbers) {
		if (sorted_numbers.total_count == 0) {
			alert('Nic nie ma!');
			return;
		}

		let sections_with_items = [];
		Object.keys(STORAGE_SECTION_NAMES).forEach(section => {
			if (sorted_numbers.sections.hasOwnProperty(section) && sorted_numbers.sections[section].length > 0) {
				sections_with_items.push(section);
			}
		});

		let excel_rows = [[]];
		let columns = [];
		let item_count_in_largest_section = 0;
		const MIN_WIDTH = 7;

		sections_with_items.forEach(section => {
			excel_rows[0].push({
				value: STORAGE_SECTION_NAMES[section], 
				fontWeight: 'bold',
				align: 'center',
				backgroundColor: '#afb3b1',
			});

			let width = section.length + 1;
			columns.push({width:width < MIN_WIDTH ? MIN_WIDTH : width});

			if (sorted_numbers.sections[section].length > item_count_in_largest_section) {
				item_count_in_largest_section = sorted_numbers.sections[section].length;
			}
		});
		
		for(let row=0; row<item_count_in_largest_section; row++) {
			let excel_row = [];
			
			for(let column=0; column<sections_with_items.length; column++) {
				let section       = sections_with_items[column];
				let current_value = sorted_numbers.sections[section] && sorted_numbers.sections[section][row] ? sorted_numbers.sections[section][row] : '';
				
				excel_row.push({
					type: String, 
					value: current_value,
				});

				if (row % 2) {
					excel_row[excel_row.length-1].backgroundColor = '#e4e4e4';
				}
				
				if (current_value.length > columns[column].width) {
					columns[column].width = current_value.length;
				}
			}

			excel_rows.push(excel_row);
		}

		writeXlsxFile(excel_rows, {
			columns,
			fileName: generate_file_name() + '.xlsx'
		})
	}

	function generate_csv(sorted_numbers) {
		if (sorted_numbers.total_count == 0) {
			alert('Nie ma nic do eksportowania');
			return;
		}
		
		let sections_with_items = [];
		Object.keys(STORAGE_SECTION_NAMES).forEach(section => {
			if (sorted_numbers.sections.hasOwnProperty(section) && sorted_numbers.sections[section].length > 0) {
				sections_with_items.push(section);
			}
		});

		let csv = '';
		let item_count_in_largest_section = 0;

		sections_with_items.forEach((section, index) => {
			csv += (index>0?',':'') + STORAGE_SECTION_NAMES[section];
			
			if (sorted_numbers.sections[section].length > item_count_in_largest_section) {
				item_count_in_largest_section = sorted_numbers.sections[section].length;
			}
		});
		
		for(let row=0; row<item_count_in_largest_section; row++) {
			csv += '\n';
			sections_with_items.forEach((section, index) => {
				csv += (index>0?',':'');
				
				if (sorted_numbers.sections[section] && sorted_numbers.sections[section][row]) {
					csv += 
						sorted_numbers.sections[section][row].id +
						(sorted_numbers.sections[section][row].tags.length>0 ? (' '+sorted_numbers.sections[section][row].tags.join(' ')) : '') +
						(sorted_numbers.sections[section][row].comments.length>0 ? (' '+sorted_numbers.sections[section][row].comments.join(' ')) : '');
				}
			});
		}

		let blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
		let dl_link = document.createElement('a');
		dl_link.href = URL.createObjectURL(blob);
		dl_link.download = generate_file_name() + '.csv';
		dl_link.click();
	}

	function print_html_table() {
		let output = document.getElementById('output');

		if (output == '') {
			alert('Nie ma nic do wydrukowania');
			return;
		}

		toggle_controls(0);

		setTimeout(() => {
			print();
		}, 200);

		// Remove highlight color
		let saved_color = '';
		let saved_style = null;

		for (let i=0; i<document.styleSheets.length; i++) {
			for (let j=0; j<document.styleSheets[i].cssRules.length; j++) {
				if (document.styleSheets[i].cssRules[j].selectorText == '.color_flash') {
					saved_style = document.styleSheets[i].cssRules[j];
					saved_color = document.styleSheets[i].cssRules[j].style.backgroundColor;
					document.styleSheets[i].cssRules[j].style.backgroundColor = 'transparent';
				}
			}
		}

		output.addEventListener('click', function(e) {
				toggle_controls(1);
				saved_style.style.backgroundColor = saved_color;
			}, {once: true}
		);
	}

	function toggle_controls(show) {
		let controls = document.getElementById('controls');
		let caption  = document.querySelector('caption');

		if (show) {
			controls.style.display = 'block';
			caption.style.display  = 'none';
		} else {
			controls.style.display = 'none';
			caption.style.display  = 'table-caption';
		}
	}

	function toggle_strike(dom_item) {
		let word_without_comment = get_id_without_comment(dom_item.textContent);

		if (strike_list.includes(word_without_comment)) {
			strike_list = strike_list.filter(item => item !== word_without_comment);
			dom_item.style.setProperty('text-decoration', '');
		} else {
			strike_list.push(word_without_comment);
			dom_item.style.setProperty('text-decoration', 'line-through');
		}

		localStorage.setItem('strike_list', JSON.stringify(strike_list));
	}

	function get_id_without_comment(text) {
		let tokens = [];
		text.trim().split(/\s+/).forEach((word,index)=> {
			if (index==0 || (index>0 && /^[a-zA-Z0-9]/.test(word))) {
				tokens.push(word);
			}
		});

		return tokens.join(' ');
	}
	</script>
</body>
</html>