<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta http-equiv="x-ua-compatible" content="ie=edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Storage sorting</title>
	<script src="https://unpkg.com/read-excel-file@5.x/bundle/read-excel-file.min.js"></script>
	<script src="https://unpkg.com/write-excel-file@1.x/bundle/write-excel-file.min.js"></script>
	<style>
	table {
  		border-collapse: collapse;
	}
	th {
		text-align: center;
		background-color: #afb3b1;
		border: 1px solid #ddd;
		padding: 8px;
	}
	td {
		border: 1px solid #ddd;
		padding-left: 8px;
		padding-right: 8px;
		font-size: small;
	}
	tr:nth-child(even) {
		background-color: #e4e4e4;
	}
	tr:hover {
		background-color: #acacac;
	}
	#draganddrop_field {
		background-color: rgb(236, 228, 228); 
		border:1px solid brown; 
		max-width:300px; 
		height:150px; 
		margin-bottom:2em; 
		text-align:center; 
		padding-top:1em;
	}
	</style>
</head>

<body>
	<span id="controls">
		<div id="draganddrop_field" ondrop="drop_handler(event, this);" ondragover="drag_over_handler(event, this, 1);" ondragleave="drag_over_handler(event, this, 0);">
			Przeciągnij i upuść tutaj plik excel<br><br>
			<input type="file" multiple="multiple" onchange="parse_dropped_file(this)">
		</div>

		<textarea id="input"></textarea>
		<br>
		<button type="button" onclick="generate_spreadsheet(sort_numbers_to_shelves(document.getElementById('input').value, storage))" style="margin-bottom:25px">Utwórz plik excel</button>
		<button type="button" onclick="print_html_table()">Wydrukuj</button>
	</span>
	<div id="output"></div>

	<script>
	const DEFAULT_PREFIX = 'aa';
	const MAX_DIGITS = 5;

	var column_names = {
		"a": "Szafa #1",
		"b": "Szafa #2",
		"c": "Szafa #3",
		"p": "Piwnica",
		"non_matching": "Nieprzypisane",
	};

	var raw_storage_key = `
	A17 - AA 30915 - AA 38199 
	A19 - AA 38200 - AA 43899 
	A20 - AA 43900 - AA 49799 
	A21 - AA 49800 - AA 55399 
	A23 - AA 55400 - AA 60899 
	A24 - AA 60900 - AA 66099 
	A25 - AA 66100 - AA 71099 
	A26 - AA 71100 - AA 75799 
	A30 - AA 75800 - AA 81299 
	A32 - AA 81300 - AA 86399 
	A35 - AA 86400 - AA 91299 
	A36 - AA 91300 - AA 95999 
	A37 - AA 96000 - AA 99998 

	A40: AA 0002R - AA 3099R 
	A29: AA 3100R - AA 6599R 
	A22: AA 6600R - AA 9999R 
	A43: AA 0003C - AA 4299C 
	A44: AA 4300C - AA 9230C 
	A9: AA 9213C - AA 9999C, AA 0001U - AA 3319U
	A38: AA 3320U - AA 7169U 
	A2: AA 7170U - AA 9999U, AA 0001V - AA 0497V 
	A3: AA 0498V - AA 3785V 
	A4: AA 3786V - AA 7041V 
	A7: AA 7042V - AA 9999V, AA 0001W - AA 0237W
	A8: AA 0238W - AA 3517W 
	A5: AA 3518W - AA 6725W 
	A46: AA 6726W - AA 9999W 

	A47: AA 0001X - AA 3350X 
	A28: AA 3351X - AA 6600X 
	A48: AA 6601X - AA 9961X 
	A41: AA 9962X - AA 9999X, HF,HG,0-350HH 
	A14: 351HH,HJ,0-500HK 
	A13: 501HK,HL,HM, 
	A16: HN,HP,0-399HR, 
	A31: 400HR, HS, 0-799HT
	A1: 800HT,HU,HV,0-500HW
	A15: 501HW,HY,JA,JC
	A33: CA,CC,0-890CE 
	A34: 891CE,CF,CG,0-645CH 
	A10:646CH,CJ,CK,0-370CL 
	A11:371CL,CM,CN 
	A12:CP,CR,CS 
	A27:CT,CU,CV 
	A6:CW,CX,CY, 

	A18 - AA 001T, AA 001U,AA 001V-900V 
	A42: A2 3301-A2 5728

	B6: AA 0001E-AA 4659E
	B12: AA 4660E- AA 9000E
	B13: AA 9002E,AA 0-3339F
	B14: AA 3340F - AA 7610F
	B15: AA 7611F - AA 9999F ,AA 0001G-AA 1808G
	B16: AA 1809G - AA 6265G
	B21: AA 6266G- AA 9999G ,AA 0001H-AA 0629H
	B24: AA 0630H- AA 4810H
	B25: AA 4811H- AA 8749H
	B26: AA 8750H-AA 9999H, AA 0001J-AA 3129J
	B27: AA 3130J- AA 7110J
	B28: AA 7111J, AA 0-AA 1040K
	B30: AA 1041K - AA 5030K
	B32:AA 5031K- AA 9070K
	B33: AA 9071K - AA 9999K,AA 0001L- AA 3120L
	B41:AA 901V,001W,001HX,AE*,AJ*,AM*,AN*,A2 2552-A2 5434
	B37: AA 3122L-AA 7220L
	B39:AA 7221L-AA 9999L
	B43: AA 0002N- AA 1810N
	B35: AA 1811N- AA 5279N
	B44: AA 5280N- AA 8679N
	B46: AA 8680N- AA 9999N, AA 0001P-AA 1915P
	B17: AA 1916P- AA 4969P
	B48: AA 4970P- AA 8049P
	B3: AA 8050P- AA 9999P, AA 0001S- AA 1192S
	B2: AA 1193S - AA 4319S
	B20: AA 4320S- AA 7469S
	B9: AA 7470S- AA 9999S,AA 0000T- AA 0576T
	B10: AA 0577T - AA 3820T

	B11: AA 3821T - AA 6889T
	B31: AA 6890T - AA 9999T
	B18: AA 0001Y - AA 2999Y
	B45: AA 6181Y - AA 9440Y
	B36: AA 9441Y , AA,AC,0-760AE
	B4: AA 761AE,AF,AG,AH,0-250AJ
	B5: AA 251AJ,AK,AL,0-420AM
	B19: AA 421AM,AN,AP,0-600AR
	B22: AA 601AR,AS,AT,0-615AU
	B29: AA 617AU,AV,AW
	B38: AX,AY,AA 3889-AA 4611
	B8: AA 0001-AA 3888

	B34: AA 001L- AA 999L
	B47: EA,EC
	B7: EE,0-199EF
	B23: AA 200EF, EG,EH,0-120EJ
	B40: AA 121EJ,EK,EL,0-119EM
	B42: AA 120EM,EN,EP

	C01 ER, ES, 001-630ET
	C02 631ET, EU, EV,0-370EW
	C03 371EW, EY, FA,
	C04 FC, FE, 0-690FF
	C05 691FF,FG,FH
	C06 FJ, FK
	C07 FL, FM, 0-499FN
	C08 500FN, FP, FR
	C09 FS, FT, 0-499FU
	C10 AA 3000Y - AA 6180Y
	C11 500FU, FV, FW
	C12 FY, GA, 0-499GC
	C13 AAA..,AAU..,AAA..
	C24 AGR..,AKL..-PRZ..
	C23 PS..-ZZZ..

	C14 500GC, GE, 0-499GF
	C15 500GF, GG, GH
	C16 GJ, GK,0-300GL
	C17 331GL, GM,0-600GN
	C18 601GN, GP,0-800GR
	C19 801GR, GS,GT

	C20 GU,GV,0-370GW
	C21 371GW,GY,0-700HA
	C22 701HA,HC,HE
	C27 AA 0001M - AA 1330M
	C28 AA 4331M - 8169M
	C29 AA 8170M - 9999M, EX
	C25 FX, GX, 0-600HX
	C26 AA 001R-999R, AA 0-999S, AA 001L, 601HX

	A42 length:4
	`;

	var raw_storage_map = `
	A:
	entry:100
	   P   T
	1      113
	2  62
	3  1
	4  50
	5      93
	6      77
	7  42
	8  77
	9  46
	10     20
	11 81
	12     56
	13     12
	14 34
	15     16
	16 70
	17     44
	18     97
	19     24
	20 30
	21     32
	22 66
	23 38
	24 58
	25     4
	26     101
	27 22
	28 54
	29     81
	30     85
	31     36
	32     40
	33 85
	34     105
	35     60
	36 26
	37     89
	38 89
	39 115
	40     28
	41     8
	42     48
	43     52
	44 64
	45     72
	46     109
	47 93
	48     68
	
	B:
	entry:100
	   P   T
	1  115
	2      13
	3      65
	4      25
	5      33
	6      113
	7  81
	8      37
	9      21
	10 27
	11 63
	12     105
	13     85
	14 31
	15     101
	16 23
	17     109
	18     45
	19 39
	20     81
	21 47
	22 85
	23     57
	24     5
	25     41
	26     77
	27     61
	28 1
	29 43
	30     97
	31 67
	32     29
	33 51
	34 72
	35     89
	36 55
	37 93
	38     93
	39 89
	40 77
	41     1
	42 59
	43     53
	44     9
	45     49
	46     17
	47 35
	48     69

	C:
	entry:99
	   P   T
	1  85
	2      83
	3  77
	4      67
	5      1
	6      116
	7  65
	8      95
	9      103
	10     75
	11 120
	12 116
	13     120
	14 73
	15 69
	16 4
	17 30
	18 26
	19     29
	20     110
	21     79
	22 81
	23     99
	24     91
	25     59
	26     63
	27 61
	28     71
	29     87
	`;

	var test = `
	B13: AA 9002E,AA 0-3339F
	B28: AA 7111J, AA 0-AA 1040K
	`;`
	C6 AGR..-PRZ..
	C2 AA 0001U - AA 3319U
	C1 AA 30915 - AA 38199 
	C4 0-350HH
	C3 HG
	C5 AE*
	C6 AGR..-PRZ..`;
	var storage = raw_storage_key_to_array(raw_storage_key);
	storage.map = raw_storage_map_to_array(raw_storage_map);

	var original_color = document.getElementById("draganddrop_field").style.backgroundColor;

	
	function is_numeric(str) {
		if (typeof str != "string") return false
		return !isNaN(str) && !isNaN(parseFloat(str))
	}

	function raw_storage_key_to_array(input_text) {
		function is_space(input_character) {
			return /\s/.test(input_character);
		}

		function is_separator(input_character) {
			return is_space(input_character) || input_character==':' || input_character=='-';
		}

		function pad_number(input) {
			return parseInt('9'.repeat(MAX_DIGITS - input.length));
		}

		let output = {
			pattern: [],
			columns: [],
		};

		input_text.toLowerCase().split(/\r?\n/).forEach(line => {
			line = line.trim();
			if (line.length == 0)
				return;

			let i = 0;
			while(i<line.length && !is_separator(line[i])) i++;

			let column = 0;
			let shelf = 0;
			let identifier_items = line.substr(0,i).match(/[a-zA-Z]+|[0-9]+/g);
			if (identifier_items.length >= 2) {
				column = identifier_items[0];
				shelf = parseInt(identifier_items[1]);
			}
			
			if (!output.columns.includes(column)) {
				output.columns.push(column);
			}

			while(i<line.length && is_separator(line[i])) i++;
			let tokens = line.substr(i).split(/,/);
			
			function parse_range(input) {
				let output = {
					prefix:DEFAULT_PREFIX,
					number:'',
					suffix:'',
				};

				if (input.substring(input.length-1) == '*') {
					output.prefix = input.substring(0,input.length-1);
					return output;
				}

				if (input.substring(input.length-2) == '..') {
					output.prefix_range = input.substring(0,input.length-2);
					return output;
				}

				const length_keyword = 'length:';
				if (input.substring(0,length_keyword.length) == length_keyword) {
					output.length = parseInt(input.substring(length_keyword.length));
					return output;
				}
				
				let parts = input.trim().split(/\s/);
				output.prefix = parts.length>1 ? parts[0] : DEFAULT_PREFIX;

				let right = parts.length>1 ? parts[1] : parts[0];

				parts = right.match(/[a-zA-Z]+|[0-9]+/g).forEach(item => {
					if (is_numeric(item) && output.number.length==0)
						output.number = item;
					else 
						if (!is_numeric(item) && output.suffix.length==0)
							output.suffix = item;
				});
				
				return output;
			}

			tokens.forEach(token => {
				token = token.trim();
				if (token.length == 0)
					return;

				let range = token.split(/-/).map((x) => parse_range(x));

				let pattern = {
					column: column,
					shelf: shelf,
					suffix: range.length>1 ? range[1].suffix : range[0].suffix
				};

				let last = range.length>1 ? 1 : 0;
				if (range[last].prefix != DEFAULT_PREFIX) {
					pattern.prefix = range[last].prefix;
				}
				
				// input is two numbers (e.g 0-100)
				if (range.length > 1 && range[1].number!='' && range[0].number!='') {
					pattern.start = parseInt(range[0].number);
					pattern.end = parseInt(range[1].number);
					pattern.digits = range[1].number.length;
				} else
					// input is one number (e.g 100)
					if (range.length > 0 && range[0].number!='') {
						pattern.start = parseInt(range[0].number);
						pattern.end = pad_number(pattern.suffix);
						pattern.digits = range[0].number.length;
					} else
						// input is letters (e.g AA)
						if (pattern.suffix != '') {
							pattern.start = 0;
							pattern.end = pad_number(pattern.suffix);
							pattern.digits = pattern.end.toString().length;
						}

				if (range.length > 0 && range[0].hasOwnProperty("prefix_range")) {
					pattern.prefix_start = range[0].prefix_range;
					pattern.prefix_end = range[0].prefix_range;

					if (range.length > 1 && range[1].hasOwnProperty("prefix_range")) {
						pattern.prefix_end = range[1].prefix_range;
					}
				}

				if (range[0].hasOwnProperty("length")) {
					pattern.length = range[0].length;
				}				

				output.pattern.push(pattern);
			});
		});

		return output;
	}

	function raw_storage_map_to_array(input_text) {
		let output = {};
		let column = '';
		let lower = 0;
		let higher = 0;
		const entry_keyword = 'entry:';

		input_text.toLowerCase().split(/\r?\n/).forEach(line => {
			line = line.trim();
			if (line.length == 0)
				return;

			let colon = line.indexOf(':');
			if (colon >= 0) {
				if (line.substring(0,entry_keyword.length) == entry_keyword) {
					output[column].entry_point = parseInt(line.substring(entry_keyword.length));
				} else {
					if (Object.keys(column_names).includes(line.substring(0,colon))) {
						column = line.substring(0,colon);
						output[column] = {entry_point:0, entry_is_up:false};
						lower = 0;
						higher = 0;
					}
				}
			} else {
				tokens = line.split(/[\s]+/);
				if (tokens.length >= 2 && is_numeric(tokens[0]) && is_numeric(tokens[1])) {
					let shelf = parseInt(tokens[0]);
					let position = parseInt(tokens[1]);
					output[column][shelf] = position;

					if (position >= output[column].entry_point) {
						higher++;
					} else {
						lower++;
					}

					output[column].entry_is_up = lower > higher;
				}
			}
		});

		return output;
	}

	function sort_numbers_to_shelves(input_text, storage) {
		let output = {
			columns: {non_matching: []},
			total_count: 0, 
		};
		let initial_list = {};
		storage.columns.forEach(name => {
			output.columns[name] = []; 
			initial_list[name]   = [];
		});

		function compare_letters(start, target, end) {
			if (target == start || target == end)
				return true;

			let array = [start, target, end];
			array.sort();
			return target == array[1];
		}

		function get_number(line, prefix) {
			if (prefix.length > 0 && line.substring(0,prefix.length)==prefix)
				line = line.substring(prefix.length);

			if (line.length > 0) {
				let parts = line.match(/[a-zA-Z]+|[0-9]+/g);
			
				if (parts) {
					for(let i=0; i<parts.length; i++) {
						if (is_numeric(parts[i]))
							return parts[i];
					}
				}
			}

			return '-1';
		}
		
		input_text.split(/\r?\n/).forEach(line => {
			let current = line.toLowerCase().replace(/\s/g, '');
			if (current.length == 0) 
				return;

			let parts = current.match(/[a-zA-Z]+|[0-9]+/g);
			let current_prefix = parts.length > 0 ? parts[0] : '';
			let current_number = parts.length > 1 ? parts[1] : '-1';
			let suffix = parts.length>0 && parts[parts.length-1]!=current_number ? parts[parts.length-1] : '';
			let matched = false;

			for(let i=0; i<storage.pattern.length && !matched; i++) {
				let prefix = current_prefix;
				let number = current_number;

				// todo: handle this with a function
				if (storage.pattern[i].hasOwnProperty('prefix') && /[0-9]/.test(storage.pattern[i].prefix)) {
					prefix = current.substring(0,storage.pattern[i].prefix.length);
					number = get_number(current,storage.pattern[i].prefix);
				}
				
				if (
					(!storage.pattern[i].hasOwnProperty('length') ||
					current.length == storage.pattern[i].length)
					&&
					(
						(
							storage.pattern[i].hasOwnProperty('prefix_start') && 
							storage.pattern[i].hasOwnProperty('prefix_end') && 
							compare_letters(storage.pattern[i].prefix_start,parts[0],storage.pattern[i].prefix_end)
						)
						||
						(
							(
								(!storage.pattern[i].hasOwnProperty('prefix') && prefix==DEFAULT_PREFIX) || 
								prefix == storage.pattern[i].prefix
							)
							&&
							suffix == storage.pattern[i].suffix
						)
					)
					&&
					((!storage.pattern[i].hasOwnProperty('start') || !storage.pattern[i].hasOwnProperty('end') || !storage.pattern[i].hasOwnProperty('digits')) ||
					parseInt(number) >= storage.pattern[i].start && parseInt(number)<=storage.pattern[i].end && number.length==storage.pattern[i].digits)
				) {
					if (!initial_list[storage.pattern[i].column].hasOwnProperty(storage.pattern[i].shelf)) {
						initial_list[storage.pattern[i].column][storage.pattern[i].shelf] = [];
					}

					initial_list[storage.pattern[i].column][storage.pattern[i].shelf].push(line);
					output.total_count++;
					matched = true;
				}
			}
			
			if (!matched) {
				output.columns.non_matching.push(line);
				output.total_count++;
			}
		});

		storage.columns.forEach(name => {
			let bigger_half = [];
			let smaller_half = [];

			Object.keys(initial_list[name]).forEach(subarray_key => {
				initial_list[name][subarray_key].sort();
				subarray_key = parseInt(subarray_key);

				if (
					(storage.map[name].entry_is_up && storage.map[name][subarray_key] >= storage.map[name].entry_point) 
					|| 
					(!storage.map[name].entry_is_up && storage.map[name][subarray_key] < storage.map[name].entry_point)
				) {
					smaller_half.push(subarray_key);
				} else {
					bigger_half.push(subarray_key);
				}
			});

			// todo: test when entry_is_up is negative
			// todo: need to run more simulations in order to asses where we should start
			bigger_half.sort(function(x,y) {
				if (storage.map[name][x] < storage.map[name][y]) return 1;
				if (storage.map[name][x] > storage.map[name][y]) return -1;
				return 0;
			});

			smaller_half.sort(function(x,y) {
				if (storage.map[name][x] < storage.map[name][y]) return 1;
				if (storage.map[name][x] > storage.map[name][y]) return -1;
				return 0;
			});
			smaller_half.push(...bigger_half);

			smaller_half.forEach(key => {
				initial_list[name][key].forEach(item => {
					output.columns[name].push(key+': '+item);
				})
			});
		});
		
		return output;
	}


	input.addEventListener("input", function(e){
		document.getElementById("output").innerHTML = generate_html_table(sort_numbers_to_shelves(e.target.value, storage));
	});

	document.addEventListener("DOMContentLoaded", function(event) {
		document.getElementById("output").innerHTML = generate_html_table(sort_numbers_to_shelves(document.getElementById("input").value, storage));
	});
	
	function drop_handler(event, field) {
		event.preventDefault();
		parse_dropped_file(event.dataTransfer);
		field.style.backgroundColor = original_color;
	}
	
	function drag_over_handler(event, field, enable) {
		event.preventDefault();
		field.style.backgroundColor = enable ? "coral" : original_color;
	}

	function parse_dropped_file(input) {
		readXlsxFile(input.files[0]).then(function(rows) {
			let text = "";
			
			rows.forEach(row => {
				if (row.length >= 7) {
					text += row[6] + "\n";
				}
			});

			let textarea = document.getElementById("input");
			textarea.value = text;
			textarea.dispatchEvent(new Event('input'));
		});
	}


	function generate_html_table(sorted_numbers) {
		if (sorted_numbers.total_count == 0) {
			return '';
		}
		
		let key = [];
		Object.keys(column_names).forEach(column_name => {
			if (sorted_numbers.columns.hasOwnProperty(column_name) && sorted_numbers.columns[column_name].length > 0) {
				key.push(column_name);
			}
		});

		let thead = '';
		let highest_count = 0;

		key.forEach(name => {
			thead += '<th>' + column_names[name] + '</th>';
			
			if (sorted_numbers.columns[name].length > highest_count) {
				highest_count = sorted_numbers.columns[name].length;
			}
		});

		let j = 0;
		let rows = '';
		
		for(let j=0; j<highest_count; j++) {
			let row = '';
			
			for(let i=0; i<key.length; i++) {
				row += '<td>' + (sorted_numbers.columns[key[i]] && sorted_numbers.columns[key[i]][j] ? sorted_numbers.columns[key[i]][j] : '') + '</td>';
			}
			
			rows += '<tr>' + row + '</tr>';
		}

		return '<table><thead><tr>' + thead + '</tr></thead><tbody>' + rows + '</tbody></table>';
	}

	function generate_spreadsheet(sorted_numbers) {
		if (sorted_numbers.total_count == 0) {
			alert("Nic nie ma!");
			return;
		}

		let key = [];
		Object.keys(column_names).forEach(column_name => {
			if (sorted_numbers.columns.hasOwnProperty(column_name) && sorted_numbers.columns[column_name].length > 0) {
				key.push(column_name);
			}
		});

		let excel_rows = [[]];
		let columns = [];
		let highest_count = 0;
		const min_width = 7;

		key.forEach(name => {
			excel_rows[0].push({
				value: column_names[name], 
				fontWeight: 'bold',
				align: 'center',
				backgroundColor: '#afb3b1',
			});

			let width = name.length + 1;
			columns.push({width:width < min_width ? min_width : width});

			if (sorted_numbers.columns[name].length > highest_count) {
				highest_count = sorted_numbers.columns[name].length;
			}
		});
		
		for(let j=0; j<highest_count; j++) {
			let excel_row = [];
			
			for(let i=0; i<key.length; i++) {
				let current_value = sorted_numbers.columns[key[i]] && sorted_numbers.columns[key[i]][j] ? sorted_numbers.columns[key[i]][j] : '';
				
				excel_row.push({
					type: String, 
					value: current_value,
				});

				if (j % 2) {
					excel_row[excel_row.length-1].backgroundColor = '#e4e4e4';
				}
				
				if (current_value.length > columns[i].width) {
					columns[i].width = current_value.length;
				}
			}

			excel_rows.push(excel_row);
		}
		
		var today = new Date();
		var dd    = String(today.getDate()).padStart(2, '0');
		var mm    = String(today.getMonth() + 1).padStart(2, '0');
		var hh    = String(today.getHours()).padStart(2, '0');
		var min   = String(today.getMinutes()).padStart(2, '0');
		var yyyy  = today.getFullYear();

		writeXlsxFile(excel_rows, {
			columns,
			fileName: 'lista' + yyyy + '_' + mm + '_' + dd + '-' + hh + '-' + min + '.xlsx'
		})
	}

	function print_html_table() {
		if (document.getElementById("output").innerHTML == "") {
			alert("Nie ma nic do wydrukowania");
			return;
		}

		document.getElementById('controls').style.display = 'none';
		print();
	}
	</script>
</body>
</html>